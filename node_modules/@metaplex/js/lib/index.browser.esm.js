import axios from 'axios';
import { clusterApiUrl, Connection as Connection$1, PublicKey, Transaction as Transaction$1, TransactionInstruction, SYSVAR_CLOCK_PUBKEY, SYSVAR_RENT_PUBKEY, SystemProgram, Keypair } from '@solana/web3.js';
import { Buffer as Buffer$1 } from 'buffer';
import { BinaryReader, BinaryWriter, serialize, deserializeUnchecked, deserialize as deserialize$3 } from 'borsh';
import bs58 from 'bs58';
import { sha256 } from 'crypto-hash';
import BN from 'bn.js';
import { TOKEN_PROGRAM_ID, AccountLayout, u64, MintLayout, Token, ASSOCIATED_TOKEN_PROGRAM_ID, NATIVE_MINT } from '@solana/spl-token';

var Currency;
(function (Currency) {
    Currency["USD"] = "usd";
    Currency["EUR"] = "eur";
    Currency["AR"] = "ar";
    Currency["SOL"] = "sol";
})(Currency || (Currency = {}));

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

class Coingecko {
    static translateCurrency(currency) {
        switch (currency) {
            case Currency.AR:
                return 'arweave';
            case Currency.SOL:
                return 'solana';
            case Currency.USD:
                return 'usd';
            case Currency.EUR:
                return 'eur';
            default:
                throw new Error('Invalid currency supplied to Coingecko conversion rate provider');
        }
    }
    getRate(from, to) {
        return __awaiter(this, void 0, void 0, function* () {
            const fromArray = typeof from === 'string' ? [from] : from;
            const toArray = typeof to === 'string' ? [to] : to;
            const fromIds = fromArray.map((currency) => Coingecko.translateCurrency(currency)).join(',');
            const toIds = toArray.map((currency) => Coingecko.translateCurrency(currency)).join(',');
            const url = `https://api.coingecko.com/api/v3/simple/price?ids=${fromIds}&vs_currencies=${toIds}`;
            const response = yield axios(url);
            const data = yield response.data;
            return fromArray.reduce((previousPairs, fromCurrency) => {
                return [
                    ...previousPairs,
                    ...toArray.map((toCurrency) => ({
                        from: fromCurrency,
                        to: toCurrency,
                        rate: data[Coingecko.translateCurrency(fromCurrency)][Coingecko.translateCurrency(toCurrency)],
                    })),
                ];
            }, []);
        });
    }
}

/* eslint-env browser */

var browser = typeof self == 'object' ? self.FormData : window.FormData;

const ARWEAVE_URL = 'https://arweave.net';
const LAMPORT_MULTIPLIER = Math.pow(10, 9);
const WINSTON_MULTIPLIER = Math.pow(10, 12);
class ArweaveStorage {
    constructor({ endpoint, env }) {
        this.endpoint = endpoint;
        this.env = env;
    }
    getAssetCostToStore(files, arweaveRate, solanaRate) {
        return __awaiter(this, void 0, void 0, function* () {
            const buffers = Array.from(files.values());
            const totalBytes = buffers.reduce((sum, f) => (sum += f.byteLength), 0);
            const txnFeeInWinstons = parseInt(yield (yield axios(`${ARWEAVE_URL}/price/0`)).data);
            const byteCostInWinstons = parseInt(yield (yield axios(`${ARWEAVE_URL}/price/${totalBytes.toString()}`)).data);
            const totalArCost = (txnFeeInWinstons * buffers.length + byteCostInWinstons) / WINSTON_MULTIPLIER;
            const arMultiplier = arweaveRate / solanaRate;
            return LAMPORT_MULTIPLIER * totalArCost * arMultiplier * 1.1;
        });
    }
    upload(files, mintKey, txid) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileEntries = Array.from(files.entries());
            const tags = fileEntries.reduce((acc, [fileName]) => {
                acc[fileName] = [{ name: 'mint', value: mintKey }];
                return acc;
            }, {});
            const body = new browser();
            body.append('tags', JSON.stringify(tags));
            body.append('transaction', txid);
            body.append('env', this.env);
            fileEntries.map(([, file]) => {
                body.append('file[]', file);
            });
            const response = yield axios.post(this.endpoint, body);
            if (response.data.error) {
                return Promise.reject(new Error(response.data.error));
            }
            return response.data;
        });
    }
}

var ChainId;
(function (ChainId) {
    ChainId[ChainId["MainnetBeta"] = 101] = "MainnetBeta";
    ChainId[ChainId["Testnet"] = 102] = "Testnet";
    ChainId[ChainId["Devnet"] = 103] = "Devnet";
})(ChainId || (ChainId = {}));
const ENV = {
    devnet: {
        endpoint: clusterApiUrl('devnet'),
        ChainId: ChainId.Devnet,
    },
    'mainnet-beta': {
        endpoint: 'https://api.metaplex.solana.com/',
        ChainId: ChainId.MainnetBeta,
    },
    'mainnet-beta (Solana)': {
        endpoint: 'https://api.mainnet-beta.solana.com',
        ChainId: ChainId.MainnetBeta,
    },
    'mainnet-beta (Serum)': {
        endpoint: 'https://solana-api.projectserum.com/',
        ChainId: ChainId.MainnetBeta,
    },
    testnet: {
        endpoint: clusterApiUrl('testnet'),
        ChainId: ChainId.Testnet,
    },
};
class Connection extends Connection$1 {
    constructor(endpoint = 'mainnet-beta', commitment) {
        if (endpoint in ENV)
            endpoint = ENV[endpoint].endpoint;
        super(endpoint, commitment);
    }
}

class NodeWallet {
    constructor(payer) {
        this.payer = payer;
    }
    signTransaction(tx) {
        return __awaiter(this, void 0, void 0, function* () {
            tx.partialSign(this.payer);
            return tx;
        });
    }
    signAllTransactions(txs) {
        return __awaiter(this, void 0, void 0, function* () {
            return txs.map((tx) => {
                tx.partialSign(this.payer);
                return tx;
            });
        });
    }
    get publicKey() {
        return this.payer.publicKey;
    }
}

class Account {
    constructor(pubkey, info) {
        this.pubkey = new PublicKey(pubkey);
        this.info = info;
    }
    static from(account) {
        return new this(account.pubkey, account.info);
    }
    static load(connection, pubkey) {
        return __awaiter(this, void 0, void 0, function* () {
            const info = yield Account.getInfo(connection, pubkey);
            return new this(pubkey, info);
        });
    }
    static isCompatible(data) {
        throw new Error(`method 'isCompatible' is not implemented`);
    }
    static getInfo(connection, pubkey) {
        return __awaiter(this, void 0, void 0, function* () {
            const info = yield connection.getAccountInfo(new PublicKey(pubkey));
            if (!info) {
                throw new Error(`Unable to find account: ${pubkey}`);
            }
            return Object.assign(Object.assign({}, info), { data: Buffer$1.from(info === null || info === void 0 ? void 0 : info.data) });
        });
    }
    static getInfos(connection, pubkeys, commitment = 'recent') {
        return __awaiter(this, void 0, void 0, function* () {
            const BATCH_SIZE = 99;
            const promises = [];
            for (let i = 0; i < pubkeys.length; i += BATCH_SIZE) {
                promises.push(Account.getMultipleAccounts(connection, pubkeys.slice(i, Math.min(pubkeys.length, i + BATCH_SIZE)), commitment));
            }
            const results = new Map();
            (yield Promise.all(promises)).forEach((result) => { var _a; return [...((_a = result === null || result === void 0 ? void 0 : result.entries()) !== null && _a !== void 0 ? _a : [])].forEach(([k, v]) => results.set(k, v)); });
            return results;
        });
    }
    static getMultipleAccounts(connection, pubkeys, commitment) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = connection._buildArgs([pubkeys.map((k) => k.toString())], commitment, 'base64');
            const unsafeRes = yield connection._rpcRequest('getMultipleAccounts', args);
            if (unsafeRes.error) {
                throw new Error('failed to get info about accounts ' + unsafeRes.error.message);
            }
            if (!unsafeRes.result.value)
                return;
            const infos = unsafeRes.result.value
                .filter(Boolean)
                .map((info) => (Object.assign(Object.assign({}, info), { data: Buffer$1.from(info.data[0], 'base64') })));
            return infos.reduce((acc, info, index) => {
                acc.set(pubkeys[index], info);
                return acc;
            }, new Map());
        });
    }
    assertOwner(pubkey) {
        var _a;
        return (_a = this.info) === null || _a === void 0 ? void 0 : _a.owner.equals(new PublicKey(pubkey));
    }
    toJSON() {
        var _a, _b, _c, _d, _e;
        return {
            pubkey: this.pubkey.toString(),
            info: {
                executable: !!((_a = this.info) === null || _a === void 0 ? void 0 : _a.executable),
                owner: ((_b = this.info) === null || _b === void 0 ? void 0 : _b.owner) ? new PublicKey((_c = this.info) === null || _c === void 0 ? void 0 : _c.owner) : null,
                lamports: (_d = this.info) === null || _d === void 0 ? void 0 : _d.lamports,
                data: (_e = this.info) === null || _e === void 0 ? void 0 : _e.data.toJSON(),
            },
            data: this.data,
        };
    }
    toString() {
        return JSON.stringify(this.toJSON());
    }
}

const extendBorsh = () => {
    BinaryReader.prototype.readPubkey = function () {
        const reader = this;
        const array = reader.readFixedArray(32);
        return new PublicKey(array);
    };
    BinaryWriter.prototype.writePubkey = function (value) {
        const writer = this;
        writer.writeFixedArray(value.toBuffer());
    };
    BinaryReader.prototype.readPubkeyAsString = function () {
        const reader = this;
        const array = reader.readFixedArray(32);
        return bs58.encode(array);
    };
    BinaryWriter.prototype.writePubkeyAsString = function (value) {
        const writer = this;
        writer.writeFixedArray(bs58.decode(value));
    };
};
extendBorsh();
class Data {
    constructor(args = {}) {
        Object.assign(this, args);
    }
    static struct(fields) {
        return struct(this, fields);
    }
    static serialize(args = {}) {
        return Buffer.from(serialize(this.SCHEMA, new this(args)));
    }
    static deserialize(data) {
        return deserializeUnchecked(this.SCHEMA, this, data);
    }
}
const struct = (type, fields) => {
    return new Map([[type, { kind: 'struct', fields }]]);
};

var borsh = /*#__PURE__*/Object.freeze({
  __proto__: null,
  extendBorsh: extendBorsh,
  Data: Data,
  struct: struct,
  deserialize: deserialize$3,
  deserializeUnchecked: deserializeUnchecked,
  serialize: serialize
});

const getFileHash = (file) => __awaiter(void 0, void 0, void 0, function* () { return Buffer$1.from(yield sha256(file.toString())); });

var crypto = /*#__PURE__*/Object.freeze({
  __proto__: null,
  getFileHash: getFileHash
});

const lookup = (url) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const { data } = yield axios.get(url);
        return data;
    }
    catch (_a) {
        throw new Error(`unable to get metadata json from url ${url}`);
    }
});

var metadata = /*#__PURE__*/Object.freeze({
  __proto__: null,
  lookup: lookup
});

var TupleNumericType;
(function (TupleNumericType) {
    TupleNumericType[TupleNumericType["U8"] = 1] = "U8";
    TupleNumericType[TupleNumericType["U16"] = 2] = "U16";
    TupleNumericType[TupleNumericType["U32"] = 4] = "U32";
    TupleNumericType[TupleNumericType["U64"] = 8] = "U64";
})(TupleNumericType || (TupleNumericType = {}));
const getBNFromData = (data, offset, dataType) => {
    switch (dataType) {
        case TupleNumericType.U8:
            return new BN(data[offset], 'le');
        case TupleNumericType.U16:
            return new BN(data.slice(offset, offset + 2), 'le');
        case TupleNumericType.U32:
            return new BN(data.slice(offset, offset + 4), 'le');
        case TupleNumericType.U64:
            return new BN(data.slice(offset, offset + 8), 'le');
    }
};

var index$6 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Borsh: borsh,
  Crypto: crypto,
  metadata: metadata,
  get TupleNumericType () { return TupleNumericType; },
  getBNFromData: getBNFromData
});

var ErrorCode;
(function (ErrorCode) {
    ErrorCode[ErrorCode["ERROR_INVALID_OWNER"] = 0] = "ERROR_INVALID_OWNER";
    ErrorCode[ErrorCode["ERROR_INVALID_ACCOUNT_DATA"] = 1] = "ERROR_INVALID_ACCOUNT_DATA";
    ErrorCode[ErrorCode["ERROR_DEPRECATED_ACCOUNT_DATA"] = 2] = "ERROR_DEPRECATED_ACCOUNT_DATA";
})(ErrorCode || (ErrorCode = {}));
class MetaplexError extends Error {
    constructor(errorCode, message) {
        super(message);
        this.errorCode = errorCode;
    }
}
const ERROR_INVALID_OWNER = () => {
    return new MetaplexError(ErrorCode.ERROR_INVALID_OWNER, 'Invalid owner');
};
const ERROR_INVALID_ACCOUNT_DATA = () => {
    return new MetaplexError(ErrorCode.ERROR_INVALID_ACCOUNT_DATA, 'Invalid data');
};
const ERROR_DEPRECATED_ACCOUNT_DATA = () => {
    return new MetaplexError(ErrorCode.ERROR_DEPRECATED_ACCOUNT_DATA, 'Account data is deprecated');
};

var errors = /*#__PURE__*/Object.freeze({
  __proto__: null,
  get ErrorCode () { return ErrorCode; },
  MetaplexError: MetaplexError,
  ERROR_INVALID_OWNER: ERROR_INVALID_OWNER,
  ERROR_INVALID_ACCOUNT_DATA: ERROR_INVALID_ACCOUNT_DATA,
  ERROR_DEPRECATED_ACCOUNT_DATA: ERROR_DEPRECATED_ACCOUNT_DATA
});

class Transaction extends Transaction$1 {
    constructor(options) {
        super(options);
    }
    static fromCombined(transactions, options = {}) {
        const combinedTransaction = new Transaction(options);
        transactions.forEach((transaction) => transaction.instructions.forEach((instruction) => {
            combinedTransaction.add(instruction);
        }));
        return combinedTransaction;
    }
}

const sendTransaction = ({ connection, wallet, txs, signers = [], options, }) => __awaiter(void 0, void 0, void 0, function* () {
    let tx = Transaction.fromCombined(txs, { feePayer: wallet.publicKey });
    tx.recentBlockhash = (yield connection.getRecentBlockhash()).blockhash;
    if (signers.length) {
        tx.partialSign(...signers);
    }
    tx = yield wallet.signTransaction(tx);
    return connection.sendRawTransaction(tx.serialize(), options);
});

class Program {
    static findProgramAddress(seeds) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield PublicKey.findProgramAddress(seeds, this.PUBKEY))[0];
        });
    }
    static getProgramAccounts(connection, configOrCommitment) {
        return __awaiter(this, void 0, void 0, function* () {
            const extra = {};
            let commitment;
            if (configOrCommitment) {
                if (typeof configOrCommitment === 'string') {
                    commitment = configOrCommitment;
                }
                else {
                    commitment = configOrCommitment.commitment;
                    if (configOrCommitment.dataSlice) {
                        extra.dataSlice = configOrCommitment.dataSlice;
                    }
                    if (configOrCommitment.filters) {
                        extra.filters = configOrCommitment.filters;
                    }
                }
            }
            const args = connection._buildArgs([this.PUBKEY.toBase58()], commitment, 'base64', extra);
            const unsafeRes = yield connection._rpcRequest('getProgramAccounts', args);
            return unsafeRes.result
                .map(({ account: { data, executable, lamports, owner }, pubkey }) => ({
                account: {
                    data: Buffer$1.from(data[0], 'base64'),
                    executable,
                    lamports,
                    owner: new PublicKey(owner),
                },
                pubkey: new PublicKey(pubkey),
            }))
                .map(({ pubkey, account }) => new Account(pubkey, account));
        });
    }
}

const config = {
    arweaveWallet: 'HvwC9QSAzvGXhhVrgPmauVwFWcYZhne3hVot9EbHuFTm',
    programs: {
        auction: 'auctxRXPeJoc4817jDhf4HbjnhEcr1cCXenosMhK5R8',
        metadata: 'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s',
        metaplex: 'p1exdMJcjVao65QdewkaZRUnU6VPSXhus9n2GzWfh98',
        vault: 'vau1zxA2LbssAUEF7Gpw91zMM1LvXrvpzJtmZ58rPsn',
        packs: 'BNRmGgciUJuyznkYHnmitA9an1BcDDiU9JmjEQwvBYVR',
        memo: 'MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr',
        token: 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',
    },
    maxCreatorLimit: 5,
};

var MetaplexKey;
(function (MetaplexKey) {
    MetaplexKey[MetaplexKey["Uninitialized"] = 0] = "Uninitialized";
    MetaplexKey[MetaplexKey["OriginalAuthorityLookupV1"] = 1] = "OriginalAuthorityLookupV1";
    MetaplexKey[MetaplexKey["BidRedemptionTicketV1"] = 2] = "BidRedemptionTicketV1";
    MetaplexKey[MetaplexKey["StoreV1"] = 3] = "StoreV1";
    MetaplexKey[MetaplexKey["WhitelistedCreatorV1"] = 4] = "WhitelistedCreatorV1";
    MetaplexKey[MetaplexKey["PayoutTicketV1"] = 5] = "PayoutTicketV1";
    MetaplexKey[MetaplexKey["SafetyDepositValidationTicketV1"] = 6] = "SafetyDepositValidationTicketV1";
    MetaplexKey[MetaplexKey["AuctionManagerV1"] = 7] = "AuctionManagerV1";
    MetaplexKey[MetaplexKey["PrizeTrackingTicketV1"] = 8] = "PrizeTrackingTicketV1";
    MetaplexKey[MetaplexKey["SafetyDepositConfigV1"] = 9] = "SafetyDepositConfigV1";
    MetaplexKey[MetaplexKey["AuctionManagerV2"] = 10] = "AuctionManagerV2";
    MetaplexKey[MetaplexKey["BidRedemptionTicketV2"] = 11] = "BidRedemptionTicketV2";
    MetaplexKey[MetaplexKey["AuctionWinnerTokenTypeTrackerV1"] = 12] = "AuctionWinnerTokenTypeTrackerV1";
})(MetaplexKey || (MetaplexKey = {}));
class MetaplexProgram extends Program {
}
MetaplexProgram.PREFIX = 'metaplex';
MetaplexProgram.TOTALS = 'totals';
MetaplexProgram.PUBKEY = new PublicKey(config.programs.metaplex);

const WINNER_INDEX_OFFSETS = [2, 10];
class BidRedemptionTicket extends Account {
    constructor(pubkey, info) {
        super(pubkey, info);
        if (!this.assertOwner(MetaplexProgram.PUBKEY)) {
            throw ERROR_INVALID_OWNER();
        }
        if (BidRedemptionTicket.isBidRedemptionTicketV1(this.info.data)) {
            throw ERROR_DEPRECATED_ACCOUNT_DATA();
        }
        else if (BidRedemptionTicket.isBidRedemptionTicketV2(this.info.data)) {
            const data = this.info.data.toJSON().data;
            const winnerIndex = data[1] !== 0 && new BN(data.slice(1, 9), 'le');
            const offset = WINNER_INDEX_OFFSETS[+!!winnerIndex];
            this.data = {
                key: MetaplexKey.BidRedemptionTicketV2,
                winnerIndex,
                data,
                auctionManager: bs58.encode(data.slice(offset, offset + 32)),
            };
        }
        else {
            throw ERROR_INVALID_ACCOUNT_DATA();
        }
    }
    static isCompatible(data) {
        return (BidRedemptionTicket.isBidRedemptionTicketV1(data) ||
            BidRedemptionTicket.isBidRedemptionTicketV2(data));
    }
    static isBidRedemptionTicketV1(data) {
        return data[0] === MetaplexKey.BidRedemptionTicketV1;
    }
    static isBidRedemptionTicketV2(data) {
        return data[0] === MetaplexKey.BidRedemptionTicketV2;
    }
}

class AuctionProgram extends Program {
}
AuctionProgram.PREFIX = 'auction';
AuctionProgram.EXTENDED = 'extended';
AuctionProgram.PUBKEY = new PublicKey(config.programs.auction);

var _a$C;
class BidderMetadataData extends Data {
}
_a$C = BidderMetadataData;
BidderMetadataData.SCHEMA = _a$C.struct([
    ['bidderPubkey', 'pubkeyAsString'],
    ['auctionPubkey', 'pubkeyAsString'],
    ['lastBid', 'u64'],
    ['lastBidTimestamp', 'u64'],
    ['cancelled', 'u8'],
]);
class BidderMetadata extends Account {
    constructor(key, info) {
        super(key, info);
        if (!this.assertOwner(AuctionProgram.PUBKEY)) {
            throw ERROR_INVALID_OWNER();
        }
        if (!BidderMetadata.isCompatible(this.info.data)) {
            throw ERROR_INVALID_ACCOUNT_DATA();
        }
        this.data = BidderMetadataData.deserialize(this.info.data);
    }
    static isCompatible(data) {
        return data.length === BidderMetadata.DATA_SIZE;
    }
    static getPDA(auction, bidder) {
        return AuctionProgram.findProgramAddress([
            Buffer$1.from(AuctionProgram.PREFIX),
            AuctionProgram.PUBKEY.toBuffer(),
            new PublicKey(auction).toBuffer(),
            new PublicKey(bidder).toBuffer(),
            Buffer$1.from('metadata'),
        ]);
    }
}
BidderMetadata.DATA_SIZE = 32 + 32 + 8 + 8 + 1;

var _a$B;
class BidderPotData extends Data {
}
_a$B = BidderPotData;
BidderPotData.SCHEMA = _a$B.struct([
    ['bidderPot', 'pubkeyAsString'],
    ['bidderAct', 'pubkeyAsString'],
    ['auctionAct', 'pubkeyAsString'],
    ['emptied', 'u8'],
]);
class BidderPot extends Account {
    constructor(key, info) {
        super(key, info);
        if (!this.assertOwner(AuctionProgram.PUBKEY)) {
            throw ERROR_INVALID_OWNER();
        }
        if (!BidderPot.isCompatible(this.info.data)) {
            throw ERROR_INVALID_ACCOUNT_DATA();
        }
        this.data = BidderPotData.deserialize(this.info.data);
    }
    static isCompatible(data) {
        return data.length === BidderPot.DATA_SIZE;
    }
    static getPDA(auction, bidder) {
        return AuctionProgram.findProgramAddress([
            Buffer$1.from(AuctionProgram.PREFIX),
            AuctionProgram.PUBKEY.toBuffer(),
            new PublicKey(auction).toBuffer(),
            new PublicKey(bidder).toBuffer(),
        ]);
    }
}
BidderPot.DATA_SIZE = 32 + 32 + 32 + 1;

var _a$A, _b$6, _c$2, _d;
var AuctionState;
(function (AuctionState) {
    AuctionState[AuctionState["Created"] = 0] = "Created";
    AuctionState[AuctionState["Started"] = 1] = "Started";
    AuctionState[AuctionState["Ended"] = 2] = "Ended";
})(AuctionState || (AuctionState = {}));
var BidStateType;
(function (BidStateType) {
    BidStateType[BidStateType["EnglishAuction"] = 0] = "EnglishAuction";
    BidStateType[BidStateType["OpenEdition"] = 1] = "OpenEdition";
})(BidStateType || (BidStateType = {}));
var PriceFloorType;
(function (PriceFloorType) {
    PriceFloorType[PriceFloorType["None"] = 0] = "None";
    PriceFloorType[PriceFloorType["Minimum"] = 1] = "Minimum";
    PriceFloorType[PriceFloorType["BlindedPrice"] = 2] = "BlindedPrice";
})(PriceFloorType || (PriceFloorType = {}));
class Bid extends Data {
}
_a$A = Bid;
Bid.SCHEMA = _a$A.struct([
    ['key', 'pubkeyAsString'],
    ['amount', 'u64'],
]);
class BidState extends Data {
    getWinnerAt(winnerIndex) {
        const convertedIndex = this.bids.length - winnerIndex - 1;
        if (convertedIndex >= 0 && convertedIndex < this.bids.length) {
            return this.bids[convertedIndex].key;
        }
        else {
            return null;
        }
    }
    getAmountAt(winnerIndex) {
        const convertedIndex = this.bids.length - winnerIndex - 1;
        if (convertedIndex >= 0 && convertedIndex < this.bids.length) {
            return this.bids[convertedIndex].amount;
        }
        else {
            return null;
        }
    }
    getWinnerIndex(bidder) {
        if (!this.bids)
            return null;
        const index = this.bids.findIndex((b) => b.key === bidder);
        if (index !== -1) {
            const zeroBased = this.bids.length - index - 1;
            return zeroBased < this.max.toNumber() ? zeroBased : null;
        }
        else
            return null;
    }
}
_b$6 = BidState;
BidState.SCHEMA = new Map([
    ...Bid.SCHEMA,
    ..._b$6.struct([
        ['type', 'u8'],
        ['bids', [Bid]],
        ['max', 'u64'],
    ]),
]);
class PriceFloor extends Data {
    constructor(args) {
        super();
        this.type = args.type;
        this.hash = args.hash || new Uint8Array(32);
        if (this.type === PriceFloorType.Minimum) {
            if (args.minPrice) {
                this.hash.set(args.minPrice.toArrayLike(Buffer$1, 'le', 8), 0);
            }
            else {
                this.minPrice = new BN((args.hash || new Uint8Array(0)).slice(0, 8), 'le');
            }
        }
    }
}
_c$2 = PriceFloor;
PriceFloor.SCHEMA = _c$2.struct([
    ['type', 'u8'],
    ['hash', [32]],
]);
class AuctionData extends Data {
}
_d = AuctionData;
AuctionData.SCHEMA = new Map([
    ...BidState.SCHEMA,
    ...PriceFloor.SCHEMA,
    ..._d.struct([
        ['authority', 'pubkeyAsString'],
        ['tokenMint', 'pubkeyAsString'],
        ['lastBid', { kind: 'option', type: 'u64' }],
        ['endedAt', { kind: 'option', type: 'u64' }],
        ['endAuctionAt', { kind: 'option', type: 'u64' }],
        ['auctionGap', { kind: 'option', type: 'u64' }],
        ['priceFloor', PriceFloor],
        ['state', 'u8'],
        ['bidState', BidState],
    ]),
]);
class Auction extends Account {
    constructor(pubkey, info) {
        super(pubkey, info);
        if (!this.assertOwner(AuctionProgram.PUBKEY)) {
            throw ERROR_INVALID_OWNER();
        }
        this.data = AuctionData.deserialize(this.info.data);
    }
    static getPDA(vault) {
        return AuctionProgram.findProgramAddress([
            Buffer$1.from(AuctionProgram.PREFIX),
            AuctionProgram.PUBKEY.toBuffer(),
            new PublicKey(vault).toBuffer(),
        ]);
    }
    static findMany(connection, filters = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield AuctionProgram.getProgramAccounts(connection, {
                filters: [
                    filters.authority && {
                        memcmp: {
                            offset: 0,
                            bytes: new PublicKey(filters.authority).toBase58(),
                        },
                    },
                ].filter(Boolean),
            }))
                .map((account) => {
                try {
                    return Auction.from(account);
                }
                catch (err) { }
            })
                .filter(Boolean);
        });
    }
    getBidderPots(connection) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield AuctionProgram.getProgramAccounts(connection, {
                filters: [
                    {
                        dataSize: BidderPot.DATA_SIZE,
                    },
                    {
                        memcmp: {
                            offset: 32 + 32,
                            bytes: this.pubkey.toBase58(),
                        },
                    },
                ],
            })).map((account) => BidderPot.from(account));
        });
    }
    getBidderMetadata(connection) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield AuctionProgram.getProgramAccounts(connection, {
                filters: [
                    {
                        dataSize: BidderMetadata.DATA_SIZE,
                    },
                    {
                        memcmp: {
                            offset: 32,
                            bytes: this.pubkey.toBase58(),
                        },
                    },
                ],
            })).map((account) => BidderMetadata.from(account));
        });
    }
}
Auction.EXTENDED_DATA_SIZE = 8 + 9 + 2 + 200;

var _a$z;
class AuctionDataExtended extends Data {
}
_a$z = AuctionDataExtended;
AuctionDataExtended.SCHEMA = _a$z.struct([
    ['totalUncancelledBids', 'u64'],
    ['tickSize', { kind: 'option', type: 'u64' }],
    ['gapTickSizePercentage', { kind: 'option', type: 'u8' }],
    ['instantSalePrice', { kind: 'option', type: 'u64' }],
    ['name', { kind: 'option', type: [32] }],
]);
class AuctionExtended extends Account {
    constructor(pubkey, info) {
        super(pubkey, info);
        if (!this.assertOwner(AuctionProgram.PUBKEY)) {
            throw ERROR_INVALID_OWNER();
        }
        if (!AuctionExtended.isCompatible(this.info.data)) {
            throw ERROR_INVALID_ACCOUNT_DATA();
        }
        this.data = AuctionDataExtended.deserialize(this.info.data);
    }
    static isCompatible(data) {
        return data.length === AuctionExtended.DATA_SIZE;
    }
    static getPDA(vault) {
        return AuctionProgram.findProgramAddress([
            Buffer$1.from(AuctionProgram.PREFIX),
            AuctionProgram.PUBKEY.toBuffer(),
            new PublicKey(vault).toBuffer(),
            Buffer$1.from(AuctionProgram.EXTENDED),
        ]);
    }
}
AuctionExtended.DATA_SIZE = 8 + 9 + 2 + 200;

var _a$y;
class CancelBidArgs extends Data {
    constructor() {
        super(...arguments);
        this.instruction = 0;
    }
}
_a$y = CancelBidArgs;
CancelBidArgs.SCHEMA = _a$y.struct([
    ['instruction', 'u8'],
    ['resource', 'pubkeyAsString'],
]);
class CancelBid extends Transaction {
    constructor(options, params) {
        super(options);
        const { auction, auctionExtended, bidderPot, bidderMeta, bidder, bidderToken, bidderPotToken, tokenMint, resource, } = params;
        const data = CancelBidArgs.serialize({ resource: resource.toString() });
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: bidder,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: bidderToken,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: bidderPot,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: bidderPotToken,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: bidderMeta,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: auction,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: auctionExtended,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: tokenMint,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: SYSVAR_CLOCK_PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SYSVAR_RENT_PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SystemProgram.programId,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: TOKEN_PROGRAM_ID,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: AuctionProgram.PUBKEY,
            data,
        }));
    }
}

var _a$x, _b$5;
var WinnerLimitType;
(function (WinnerLimitType) {
    WinnerLimitType[WinnerLimitType["Unlimited"] = 0] = "Unlimited";
    WinnerLimitType[WinnerLimitType["Capped"] = 1] = "Capped";
})(WinnerLimitType || (WinnerLimitType = {}));
class WinnerLimit extends Data {
}
_a$x = WinnerLimit;
WinnerLimit.SCHEMA = _a$x.struct([
    ['type', 'u8'],
    ['usize', 'u64'],
]);
class CreateAuctionArgs extends Data {
    constructor() {
        super(...arguments);
        this.instruction = 1;
    }
}
_b$5 = CreateAuctionArgs;
CreateAuctionArgs.SCHEMA = new Map([
    ...WinnerLimit.SCHEMA,
    ...PriceFloor.SCHEMA,
    ..._b$5.struct([
        ['instruction', 'u8'],
        ['winners', WinnerLimit],
        ['endAuctionAt', { kind: 'option', type: 'u64' }],
        ['auctionGap', { kind: 'option', type: 'u64' }],
        ['tokenMint', 'pubkeyAsString'],
        ['authority', 'pubkeyAsString'],
        ['resource', 'pubkeyAsString'],
        ['priceFloor', PriceFloor],
        ['tickSize', { kind: 'option', type: 'u64' }],
        ['gapTickSizePercentage', { kind: 'option', type: 'u8' }],
    ]),
]);
class CreateAuction extends Transaction {
    constructor(options, params) {
        super(options);
        const { args, auction, auctionExtended, creator } = params;
        const data = CreateAuctionArgs.serialize(args);
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: creator,
                    isSigner: true,
                    isWritable: true,
                },
                {
                    pubkey: auction,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: auctionExtended,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: SYSVAR_RENT_PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SystemProgram.programId,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: AuctionProgram.PUBKEY,
            data,
        }));
    }
}

var _a$w;
class CreateAuctionV2Args extends Data {
    constructor() {
        super(...arguments);
        this.instruction = 7;
    }
}
_a$w = CreateAuctionV2Args;
CreateAuctionV2Args.SCHEMA = new Map([
    ...WinnerLimit.SCHEMA,
    ...PriceFloor.SCHEMA,
    ..._a$w.struct([
        ['instruction', 'u8'],
        ['winners', WinnerLimit],
        ['endAuctionAt', { kind: 'option', type: 'u64' }],
        ['auctionGap', { kind: 'option', type: 'u64' }],
        ['tokenMint', 'pubkeyAsString'],
        ['authority', 'pubkeyAsString'],
        ['resource', 'pubkeyAsString'],
        ['priceFloor', PriceFloor],
        ['tickSize', { kind: 'option', type: 'u64' }],
        ['gapTickSizePercentage', { kind: 'option', type: 'u8' }],
        ['instantSalePrice', { kind: 'option', type: 'u64' }],
        ['name', { kind: 'option', type: [32] }],
    ]),
]);
class CreateAuctionV2 extends Transaction {
    constructor(options, params) {
        super(options);
        const { args, auction, auctionExtended, creator } = params;
        const data = CreateAuctionV2Args.serialize(args);
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: creator,
                    isSigner: true,
                    isWritable: true,
                },
                {
                    pubkey: auction,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: auctionExtended,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: SYSVAR_RENT_PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SystemProgram.programId,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: AuctionProgram.PUBKEY,
            data,
        }));
    }
}

var _a$v;
class PlaceBidArgs extends Data {
    constructor() {
        super(...arguments);
        this.instruction = 6;
    }
}
_a$v = PlaceBidArgs;
PlaceBidArgs.SCHEMA = _a$v.struct([
    ['instruction', 'u8'],
    ['amount', 'u64'],
    ['resource', 'pubkeyAsString'],
]);
class PlaceBid extends Transaction {
    constructor(options, params) {
        super(options);
        const { feePayer } = options;
        const { auction, auctionExtended, bidderPot, bidderMeta, bidder, bidderToken, bidderPotToken, tokenMint, transferAuthority, resource, amount, } = params;
        const data = PlaceBidArgs.serialize({ resource: resource.toString(), amount });
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: bidder,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: bidderToken,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: bidderPot,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: bidderPotToken,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: bidderMeta,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: auction,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: auctionExtended,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: tokenMint,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: transferAuthority,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: feePayer,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: SYSVAR_CLOCK_PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SYSVAR_RENT_PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SystemProgram.programId,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: TOKEN_PROGRAM_ID,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: AuctionProgram.PUBKEY,
            data,
        }));
    }
}

var _a$u;
class SetAuctionAuthorityArgs extends Data {
    constructor() {
        super(...arguments);
        this.instruction = 5;
    }
}
_a$u = SetAuctionAuthorityArgs;
SetAuctionAuthorityArgs.SCHEMA = _a$u.struct([['instruction', 'u8']]);
class SetAuctionAuthority extends Transaction {
    constructor(options, params) {
        super(options);
        const { auction, currentAuthority, newAuthority } = params;
        const data = SetAuctionAuthorityArgs.serialize();
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: auction,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: currentAuthority,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: newAuthority,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: AuctionProgram.PUBKEY,
            data,
        }));
    }
}

var index$5 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  get AuctionState () { return AuctionState; },
  get BidStateType () { return BidStateType; },
  get PriceFloorType () { return PriceFloorType; },
  Bid: Bid,
  BidState: BidState,
  PriceFloor: PriceFloor,
  AuctionData: AuctionData,
  Auction: Auction,
  AuctionDataExtended: AuctionDataExtended,
  AuctionExtended: AuctionExtended,
  BidderMetadataData: BidderMetadataData,
  BidderMetadata: BidderMetadata,
  BidderPotData: BidderPotData,
  BidderPot: BidderPot,
  AuctionProgram: AuctionProgram,
  CancelBidArgs: CancelBidArgs,
  CancelBid: CancelBid,
  get WinnerLimitType () { return WinnerLimitType; },
  WinnerLimit: WinnerLimit,
  CreateAuctionArgs: CreateAuctionArgs,
  CreateAuction: CreateAuction,
  CreateAuctionV2Args: CreateAuctionV2Args,
  CreateAuctionV2: CreateAuctionV2,
  PlaceBidArgs: PlaceBidArgs,
  PlaceBid: PlaceBid,
  SetAuctionAuthorityArgs: SetAuctionAuthorityArgs,
  SetAuctionAuthority: SetAuctionAuthority
});

var _a$t, _b$4;
var AuctionManagerStatus;
(function (AuctionManagerStatus) {
    AuctionManagerStatus[AuctionManagerStatus["Initialized"] = 0] = "Initialized";
    AuctionManagerStatus[AuctionManagerStatus["Validated"] = 1] = "Validated";
    AuctionManagerStatus[AuctionManagerStatus["Running"] = 2] = "Running";
    AuctionManagerStatus[AuctionManagerStatus["Disbursing"] = 3] = "Disbursing";
    AuctionManagerStatus[AuctionManagerStatus["Finished"] = 4] = "Finished";
})(AuctionManagerStatus || (AuctionManagerStatus = {}));
class AuctionManagerStateV2 extends Data {
    constructor() {
        super(...arguments);
        this.status = AuctionManagerStatus.Initialized;
        this.safetyConfigItemsValidated = new BN(0);
        this.bidsPushedToAcceptPayment = new BN(0);
        this.hasParticipation = false;
    }
}
_a$t = AuctionManagerStateV2;
AuctionManagerStateV2.SCHEMA = _a$t.struct([
    ['status', 'u8'],
    ['safetyConfigItemsValidated', 'u64'],
    ['bidsPushedToAcceptPayment', 'u64'],
    ['hasParticipation', 'u8'],
]);
class AuctionManagerV2Data extends Data {
    constructor(args) {
        super(args);
        this.key = MetaplexKey.AuctionManagerV2;
    }
}
_b$4 = AuctionManagerV2Data;
AuctionManagerV2Data.SCHEMA = new Map([
    ...AuctionManagerStateV2.SCHEMA,
    ..._b$4.struct([
        ['key', 'u8'],
        ['store', 'pubkeyAsString'],
        ['authority', 'pubkeyAsString'],
        ['auction', 'pubkeyAsString'],
        ['vault', 'pubkeyAsString'],
        ['acceptPayment', 'pubkeyAsString'],
        ['state', AuctionManagerStateV2],
    ]),
]);
class AuctionManager extends Account {
    constructor(pubkey, info) {
        super(pubkey, info);
        if (!this.assertOwner(MetaplexProgram.PUBKEY)) {
            throw ERROR_INVALID_OWNER();
        }
        if (AuctionManager.isAuctionManagerV1(this.info.data)) {
            throw ERROR_DEPRECATED_ACCOUNT_DATA();
        }
        else if (AuctionManager.isAuctionManagerV2(this.info.data)) {
            this.data = AuctionManagerV2Data.deserialize(this.info.data);
        }
        else {
            throw ERROR_INVALID_ACCOUNT_DATA();
        }
    }
    static isCompatible(data) {
        return AuctionManager.isAuctionManagerV1(data) || AuctionManager.isAuctionManagerV2(data);
    }
    static isAuctionManagerV1(data) {
        return data[0] === MetaplexKey.AuctionManagerV1;
    }
    static isAuctionManagerV2(data) {
        return data[0] === MetaplexKey.AuctionManagerV2;
    }
    static getPDA(auction) {
        return MetaplexProgram.findProgramAddress([
            Buffer$1.from(MetaplexProgram.PREFIX),
            new PublicKey(auction).toBuffer(),
        ]);
    }
    static findMany(connection, filters = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield MetaplexProgram.getProgramAccounts(connection, {
                filters: [
                    {
                        memcmp: {
                            offset: 0,
                            bytes: bs58.encode(Buffer$1.from([MetaplexKey.AuctionManagerV2])),
                        },
                    },
                    filters.store && {
                        memcmp: {
                            offset: 1,
                            bytes: new PublicKey(filters.store).toBase58(),
                        },
                    },
                    filters.authority && {
                        memcmp: {
                            offset: 33,
                            bytes: new PublicKey(filters.authority).toBase58(),
                        },
                    },
                ].filter(Boolean),
            })).map((account) => AuctionManager.from(account));
        });
    }
    getAuction(connection) {
        return __awaiter(this, void 0, void 0, function* () {
            return Auction.load(connection, this.data.auction);
        });
    }
    getBidRedemptionTickets(connection, haveWinnerIndex = true) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield MetaplexProgram.getProgramAccounts(connection, {
                filters: [
                    {
                        memcmp: {
                            offset: 0,
                            bytes: bs58.encode(Buffer$1.from([MetaplexKey.BidRedemptionTicketV2])),
                        },
                    },
                    {
                        memcmp: {
                            offset: WINNER_INDEX_OFFSETS[+haveWinnerIndex],
                            bytes: this.pubkey.toBase58(),
                        },
                    },
                ],
            })).map((account) => BidRedemptionTicket.from(account));
        });
    }
}

var _a$s;
class PayoutTicketData extends Data {
    constructor(args) {
        super(args);
        this.key = MetaplexKey.PayoutTicketV1;
    }
}
_a$s = PayoutTicketData;
PayoutTicketData.SCHEMA = _a$s.struct([
    ['key', 'u8'],
    ['recipient', 'pubkeyAsString'],
    ['amountPaid', 'u64'],
]);
class PayoutTicket extends Account {
    constructor(pubkey, info) {
        super(pubkey, info);
        if (!this.assertOwner(MetaplexProgram.PUBKEY)) {
            throw ERROR_INVALID_OWNER();
        }
        if (!PayoutTicket.isCompatible(this.info.data)) {
            throw ERROR_INVALID_ACCOUNT_DATA();
        }
        this.data = PayoutTicketData.deserialize(this.info.data);
    }
    static isCompatible(data) {
        return data[0] === MetaplexKey.PayoutTicketV1;
    }
    static getPayoutTicketsByRecipient(connection, recipient) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield MetaplexProgram.getProgramAccounts(connection, {
                filters: [
                    {
                        memcmp: {
                            offset: 0,
                            bytes: bs58.encode(Buffer$1.from([MetaplexKey.PayoutTicketV1])),
                        },
                    },
                    {
                        memcmp: {
                            offset: 1,
                            bytes: new PublicKey(recipient).toBase58(),
                        },
                    },
                ],
            })).map((account) => PayoutTicket.from(account));
        });
    }
}

var _a$r;
class PrizeTrackingTicketData extends Data {
    constructor(args) {
        super(args);
        this.key = MetaplexKey.PrizeTrackingTicketV1;
        this.key = MetaplexKey.PrizeTrackingTicketV1;
    }
}
_a$r = PrizeTrackingTicketData;
PrizeTrackingTicketData.SCHEMA = _a$r.struct([
    ['key', 'u8'],
    ['metadata', 'pubkeyAsString'],
    ['supplySnapshot', 'u64'],
    ['expectedRedemptions', 'u64'],
    ['redemptions', 'u64'],
]);
class PrizeTrackingTicket extends Account {
    constructor(pubkey, info) {
        super(pubkey, info);
        if (!this.assertOwner(MetaplexProgram.PUBKEY)) {
            throw ERROR_INVALID_OWNER();
        }
        if (!PrizeTrackingTicket.isCompatible(this.info.data)) {
            throw ERROR_INVALID_ACCOUNT_DATA();
        }
        this.data = PrizeTrackingTicketData.deserialize(this.info.data);
    }
    static isCompatible(data) {
        return data[0] === MetaplexKey.PrizeTrackingTicketV1;
    }
    static getPDA(auctionManager, mint) {
        return __awaiter(this, void 0, void 0, function* () {
            return MetaplexProgram.findProgramAddress([
                Buffer$1.from(MetaplexProgram.PREFIX),
                MetaplexProgram.PUBKEY.toBuffer(),
                new PublicKey(auctionManager).toBuffer(),
                new PublicKey(mint).toBuffer(),
            ]);
        });
    }
}

var WinningConfigType;
(function (WinningConfigType) {
    WinningConfigType[WinningConfigType["TokenOnlyTransfer"] = 0] = "TokenOnlyTransfer";
    WinningConfigType[WinningConfigType["FullRightsTransfer"] = 1] = "FullRightsTransfer";
    WinningConfigType[WinningConfigType["PrintingV1"] = 2] = "PrintingV1";
    WinningConfigType[WinningConfigType["PrintingV2"] = 3] = "PrintingV2";
    WinningConfigType[WinningConfigType["Participation"] = 4] = "Participation";
})(WinningConfigType || (WinningConfigType = {}));
var WinningConstraint;
(function (WinningConstraint) {
    WinningConstraint[WinningConstraint["NoParticipationPrize"] = 0] = "NoParticipationPrize";
    WinningConstraint[WinningConstraint["ParticipationPrizeGiven"] = 1] = "ParticipationPrizeGiven";
})(WinningConstraint || (WinningConstraint = {}));
var NonWinningConstraint;
(function (NonWinningConstraint) {
    NonWinningConstraint[NonWinningConstraint["NoParticipationPrize"] = 0] = "NoParticipationPrize";
    NonWinningConstraint[NonWinningConstraint["GivenForFixedPrice"] = 1] = "GivenForFixedPrice";
    NonWinningConstraint[NonWinningConstraint["GivenForBidPrice"] = 2] = "GivenForBidPrice";
})(NonWinningConstraint || (NonWinningConstraint = {}));
class SafetyDepositConfig extends Account {
    constructor(pubkey, info) {
        super(pubkey, info);
        if (!this.assertOwner(MetaplexProgram.PUBKEY)) {
            throw ERROR_INVALID_OWNER();
        }
        if (!SafetyDepositConfig.isCompatible(this.info.data)) {
            throw ERROR_INVALID_ACCOUNT_DATA();
        }
        this.data = deserialize$2(this.info.data);
    }
    static isCompatible(data) {
        return data[0] === MetaplexKey.SafetyDepositConfigV1;
    }
    static getPDA(auctionManager, safetyDeposit) {
        return __awaiter(this, void 0, void 0, function* () {
            return MetaplexProgram.findProgramAddress([
                Buffer$1.from(MetaplexProgram.PREFIX),
                MetaplexProgram.PUBKEY.toBuffer(),
                new PublicKey(auctionManager).toBuffer(),
                new PublicKey(safetyDeposit).toBuffer(),
            ]);
        });
    }
}
const deserialize$2 = (buffer) => {
    const data = {
        key: MetaplexKey.SafetyDepositConfigV1,
        auctionManager: bs58.encode(buffer.slice(1, 33)),
        order: new BN(buffer.slice(33, 41), 'le'),
        winningConfigType: buffer[41],
        amountType: buffer[42],
        lengthType: buffer[43],
        amountRanges: [],
        participationConfig: null,
        participationState: null,
    };
    const lengthOfArray = new BN(buffer.slice(44, 48), 'le');
    let offset = 48;
    for (let i = 0; i < lengthOfArray.toNumber(); i++) {
        const amount = getBNFromData(buffer, offset, data.amountType);
        offset += data.amountType;
        const length = getBNFromData(buffer, offset, data.lengthType);
        offset += data.lengthType;
        data.amountRanges.push({ amount, length });
    }
    if (buffer[offset] == 0) {
        offset += 1;
        data.participationConfig = null;
    }
    else {
        const winnerConstraint = buffer[offset + 1];
        const nonWinningConstraint = buffer[offset + 2];
        let fixedPrice = null;
        offset += 3;
        if (buffer[offset] == 1) {
            fixedPrice = new BN(buffer.slice(offset + 1, offset + 9), 'le');
            offset += 9;
        }
        else {
            offset += 1;
        }
        data.participationConfig = {
            winnerConstraint,
            nonWinningConstraint,
            fixedPrice,
        };
    }
    if (buffer[offset] == 0) {
        offset += 1;
        data.participationState = null;
    }
    else {
        const collectedToAcceptPayment = new BN(buffer.slice(offset + 1, offset + 9), 'le');
        offset += 9;
        data.participationState = {
            collectedToAcceptPayment,
        };
    }
    return data;
};

var _a$q;
class WhitelistedCreatorData extends Data {
    constructor(args) {
        super(args);
        this.key = MetaplexKey.WhitelistedCreatorV1;
        this.activated = true;
        this.key = MetaplexKey.WhitelistedCreatorV1;
    }
}
_a$q = WhitelistedCreatorData;
WhitelistedCreatorData.SCHEMA = _a$q.struct([
    ['key', 'u8'],
    ['address', 'pubkeyAsString'],
    ['activated', 'u8'],
]);
class WhitelistedCreator extends Account {
    constructor(pubkey, info) {
        super(pubkey, info);
        if (!this.assertOwner(MetaplexProgram.PUBKEY)) {
            throw ERROR_INVALID_OWNER();
        }
        if (!WhitelistedCreator.isCompatible(this.info.data)) {
            throw ERROR_INVALID_ACCOUNT_DATA();
        }
        this.data = WhitelistedCreatorData.deserialize(this.info.data);
    }
    static isCompatible(data) {
        return data[0] === MetaplexKey.WhitelistedCreatorV1;
    }
    static getPDA(store, creator) {
        return __awaiter(this, void 0, void 0, function* () {
            return MetaplexProgram.findProgramAddress([
                Buffer$1.from(MetaplexProgram.PREFIX),
                MetaplexProgram.PUBKEY.toBuffer(),
                new PublicKey(store).toBuffer(),
                new PublicKey(creator).toBuffer(),
            ]);
        });
    }
}

var _a$p;
class StoreData extends Data {
    constructor(args) {
        super(args);
        this.key = MetaplexKey.StoreV1;
        this.public = true;
        this.key = MetaplexKey.StoreV1;
    }
}
_a$p = StoreData;
StoreData.SCHEMA = _a$p.struct([
    ['key', 'u8'],
    ['public', 'u8'],
    ['auctionProgram', 'pubkeyAsString'],
    ['tokenVaultProgram', 'pubkeyAsString'],
    ['tokenMetadataProgram', 'pubkeyAsString'],
    ['tokenProgram', 'pubkeyAsString'],
]);
class Store extends Account {
    constructor(pubkey, info) {
        super(pubkey, info);
        if (!this.assertOwner(MetaplexProgram.PUBKEY)) {
            throw ERROR_INVALID_OWNER();
        }
        if (!Store.isCompatible(this.info.data)) {
            throw ERROR_INVALID_ACCOUNT_DATA();
        }
        this.data = StoreData.deserialize(this.info.data);
    }
    static isCompatible(data) {
        return data[0] === MetaplexKey.StoreV1;
    }
    static getPDA(owner) {
        return __awaiter(this, void 0, void 0, function* () {
            return MetaplexProgram.findProgramAddress([
                Buffer$1.from(MetaplexProgram.PREFIX),
                MetaplexProgram.PUBKEY.toBuffer(),
                new PublicKey(owner).toBuffer(),
            ]);
        });
    }
    getWhitelistedCreators(connection) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield MetaplexProgram.getProgramAccounts(connection, {
                filters: [
                    {
                        memcmp: {
                            offset: 0,
                            bytes: bs58.encode(Buffer$1.from([MetaplexKey.WhitelistedCreatorV1])),
                        },
                    },
                ],
            })).map((account) => WhitelistedCreator.from(account));
        });
    }
    getAuctionManagers(connection) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield MetaplexProgram.getProgramAccounts(connection, {
                filters: [
                    {
                        memcmp: {
                            offset: 0,
                            bytes: bs58.encode(Buffer$1.from([MetaplexKey.AuctionManagerV2])),
                        },
                    },
                    {
                        memcmp: {
                            offset: 1,
                            bytes: this.pubkey.toBase58(),
                        },
                    },
                ],
            })).map((account) => AuctionManager.from(account));
        });
    }
}

class AuctionWinnerTokenTypeTracker extends Account {
    constructor(pubkey, info) {
        super(pubkey, info);
        if (!this.assertOwner(MetaplexProgram.PUBKEY)) {
            throw ERROR_INVALID_OWNER();
        }
        if (!AuctionWinnerTokenTypeTracker.isCompatible(this.info.data)) {
            throw ERROR_INVALID_ACCOUNT_DATA();
        }
        this.data = deserialize$1(this.info.data);
    }
    static isCompatible(data) {
        return data[0] === MetaplexKey.AuctionWinnerTokenTypeTrackerV1;
    }
    static getPDA(auctionManager) {
        return __awaiter(this, void 0, void 0, function* () {
            return MetaplexProgram.findProgramAddress([
                Buffer$1.from(MetaplexProgram.PREFIX),
                MetaplexProgram.PUBKEY.toBuffer(),
                new PublicKey(auctionManager).toBuffer(),
                Buffer$1.from(MetaplexProgram.TOTALS),
            ]);
        });
    }
}
const deserialize$1 = (buffer) => {
    const data = {
        key: MetaplexKey.SafetyDepositConfigV1,
        amountType: buffer[1],
        lengthType: buffer[2],
        amountRanges: [],
    };
    const lengthOfArray = new BN(buffer.slice(3, 7), 'le');
    let offset = 7;
    for (let i = 0; i < lengthOfArray.toNumber(); i++) {
        const amount = getBNFromData(buffer, offset, data.amountType);
        offset += data.amountType;
        const length = getBNFromData(buffer, offset, data.lengthType);
        offset += data.lengthType;
        data.amountRanges.push({ amount, length });
    }
    return data;
};

var VaultKey;
(function (VaultKey) {
    VaultKey[VaultKey["Uninitialized"] = 0] = "Uninitialized";
    VaultKey[VaultKey["VaultV1"] = 3] = "VaultV1";
    VaultKey[VaultKey["SafetyDepositBoxV1"] = 1] = "SafetyDepositBoxV1";
    VaultKey[VaultKey["ExternalPriceAccountV1"] = 2] = "ExternalPriceAccountV1";
})(VaultKey || (VaultKey = {}));
var VaultInstructions;
(function (VaultInstructions) {
    VaultInstructions[VaultInstructions["InitVault"] = 0] = "InitVault";
    VaultInstructions[VaultInstructions["AddTokenToInactiveVault"] = 1] = "AddTokenToInactiveVault";
    VaultInstructions[VaultInstructions["ActivateVault"] = 2] = "ActivateVault";
    VaultInstructions[VaultInstructions["CombineVault"] = 3] = "CombineVault";
    VaultInstructions[VaultInstructions["RedeemShares"] = 4] = "RedeemShares";
    VaultInstructions[VaultInstructions["WithdrawTokenFromSafetyDepositBox"] = 5] = "WithdrawTokenFromSafetyDepositBox";
    VaultInstructions[VaultInstructions["MintFractionalShares"] = 6] = "MintFractionalShares";
    VaultInstructions[VaultInstructions["WithdrawSharesFromTreasury"] = 7] = "WithdrawSharesFromTreasury";
    VaultInstructions[VaultInstructions["AddSharesToTreasury"] = 8] = "AddSharesToTreasury";
    VaultInstructions[VaultInstructions["UpdateExternalPriceAccount"] = 9] = "UpdateExternalPriceAccount";
    VaultInstructions[VaultInstructions["SetVaultAuthority"] = 10] = "SetVaultAuthority";
})(VaultInstructions || (VaultInstructions = {}));
class VaultProgram extends Program {
}
VaultProgram.PREFIX = 'vault';
VaultProgram.PUBKEY = new PublicKey(config.programs.vault);

var _a$o;
class SafetyDepositBoxData extends Data {
    constructor(args) {
        super(args);
        this.key = VaultKey.SafetyDepositBoxV1;
    }
}
_a$o = SafetyDepositBoxData;
SafetyDepositBoxData.SCHEMA = _a$o.struct([
    ['key', 'u8'],
    ['vault', 'pubkeyAsString'],
    ['tokenMint', 'pubkeyAsString'],
    ['store', 'pubkeyAsString'],
    ['order', 'u8'],
]);
class SafetyDepositBox extends Account {
    constructor(key, info) {
        super(key, info);
        if (!this.assertOwner(VaultProgram.PUBKEY)) {
            throw ERROR_INVALID_OWNER();
        }
        if (!SafetyDepositBox.isCompatible(this.info.data)) {
            throw ERROR_INVALID_ACCOUNT_DATA();
        }
        this.data = SafetyDepositBoxData.deserialize(this.info.data);
    }
    static getPDA(vault, mint) {
        return __awaiter(this, void 0, void 0, function* () {
            return VaultProgram.findProgramAddress([
                Buffer$1.from(VaultProgram.PREFIX),
                new PublicKey(vault).toBuffer(),
                new PublicKey(mint).toBuffer(),
            ]);
        });
    }
    static isCompatible(data) {
        return data[0] === VaultKey.SafetyDepositBoxV1;
    }
}

var _a$n, _b$3, _c$1;
class AmountArgs extends Data {
}
_a$n = AmountArgs;
AmountArgs.SCHEMA = _a$n.struct([
    ['instruction', 'u8'],
    ['amount', 'u64'],
]);
class NumberOfShareArgs extends Data {
}
_b$3 = NumberOfShareArgs;
NumberOfShareArgs.SCHEMA = _b$3.struct([
    ['instruction', 'u8'],
    ['numberOfShares', 'u64'],
]);
var VaultState;
(function (VaultState) {
    VaultState[VaultState["Inactive"] = 0] = "Inactive";
    VaultState[VaultState["Active"] = 1] = "Active";
    VaultState[VaultState["Combined"] = 2] = "Combined";
    VaultState[VaultState["Deactivated"] = 3] = "Deactivated";
})(VaultState || (VaultState = {}));
class VaultData extends Data {
    constructor(args) {
        super(args);
        this.key = VaultKey.VaultV1;
    }
}
_c$1 = VaultData;
VaultData.SCHEMA = _c$1.struct([
    ['key', 'u8'],
    ['tokenProgram', 'pubkeyAsString'],
    ['fractionMint', 'pubkeyAsString'],
    ['authority', 'pubkeyAsString'],
    ['fractionTreasury', 'pubkeyAsString'],
    ['redeemTreasury', 'pubkeyAsString'],
    ['allowFurtherShareCreation', 'u8'],
    ['pricingLookupAddress', 'pubkeyAsString'],
    ['tokenTypeCount', 'u8'],
    ['state', 'u8'],
    ['lockedPricePerShare', 'u64'],
]);
class Vault extends Account {
    constructor(pubkey, info) {
        super(pubkey, info);
        if (!this.assertOwner(VaultProgram.PUBKEY)) {
            throw ERROR_INVALID_OWNER();
        }
        if (!Vault.isCompatible(this.info.data)) {
            throw ERROR_INVALID_ACCOUNT_DATA();
        }
        this.data = VaultData.deserialize(this.info.data);
    }
    static getPDA(pubkey) {
        return __awaiter(this, void 0, void 0, function* () {
            return VaultProgram.findProgramAddress([
                Buffer$1.from(VaultProgram.PREFIX),
                VaultProgram.PUBKEY.toBuffer(),
                new PublicKey(pubkey).toBuffer(),
            ]);
        });
    }
    static isCompatible(data) {
        return data[0] === VaultKey.VaultV1;
    }
    getSafetyDepositBoxes(connection) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield VaultProgram.getProgramAccounts(connection, {
                filters: [
                    {
                        memcmp: {
                            offset: 0,
                            bytes: bs58.encode(Buffer$1.from([VaultKey.SafetyDepositBoxV1])),
                        },
                    },
                    {
                        memcmp: {
                            offset: 1,
                            bytes: this.pubkey.toBase58(),
                        },
                    },
                ],
            })).map((account) => SafetyDepositBox.from(account));
        });
    }
}
Vault.MAX_VAULT_SIZE = 1 + 32 + 32 + 32 + 32 + 1 + 32 + 1 + 32 + 1 + 1 + 8;
Vault.MAX_EXTERNAL_ACCOUNT_SIZE = 1 + 8 + 32 + 1;

var _a$m;
class ExternalPriceAccountData extends Data {
    constructor(args) {
        super(args);
        this.key = VaultKey.ExternalPriceAccountV1;
    }
}
_a$m = ExternalPriceAccountData;
ExternalPriceAccountData.SCHEMA = _a$m.struct([
    ['key', 'u8'],
    ['pricePerShare', 'u64'],
    ['priceMint', 'pubkeyAsString'],
    ['allowedToCombine', 'u8'],
]);
class ExternalPriceAccount extends Account {
    constructor(key, info) {
        super(key, info);
        if (!this.assertOwner(VaultProgram.PUBKEY)) {
            throw ERROR_INVALID_OWNER();
        }
        if (!ExternalPriceAccount.isCompatible(this.info.data)) {
            throw ERROR_INVALID_ACCOUNT_DATA();
        }
        this.data = ExternalPriceAccountData.deserialize(this.info.data);
    }
    static isCompatible(data) {
        return data[0] === VaultKey.ExternalPriceAccountV1;
    }
}

class ActivateVault extends Transaction {
    constructor(options, params) {
        super(options);
        const { vault, vaultAuthority, fractionMint, fractionTreasury, fractionMintAuthority, numberOfShares, } = params;
        const data = NumberOfShareArgs.serialize({
            instruction: VaultInstructions.ActivateVault,
            numberOfShares,
        });
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: vault,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: fractionMint,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: fractionTreasury,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: fractionMintAuthority,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: vaultAuthority,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: TOKEN_PROGRAM_ID,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: VaultProgram.PUBKEY,
            data,
        }));
    }
}

class AddSharesToTreasury extends Transaction {
    constructor(options, params) {
        super(options);
        const { vault, vaultAuthority, source, transferAuthority, fractionTreasury, numberOfShares } = params;
        const data = NumberOfShareArgs.serialize({
            instruction: VaultInstructions.AddSharesToTreasury,
            numberOfShares,
        });
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: source,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: fractionTreasury,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: vault,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: transferAuthority,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: vaultAuthority,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: TOKEN_PROGRAM_ID,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SYSVAR_RENT_PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: VaultProgram.PUBKEY,
            data,
        }));
    }
}

class AddTokenToInactiveVault extends Transaction {
    constructor(options, params) {
        super(options);
        const { feePayer } = options;
        const { vault, vaultAuthority, tokenAccount, tokenStoreAccount, transferAuthority, safetyDepositBox, amount, } = params;
        const data = AmountArgs.serialize({
            instruction: VaultInstructions.AddTokenToInactiveVault,
            amount,
        });
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: safetyDepositBox,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: tokenAccount,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: tokenStoreAccount,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: vault,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: vaultAuthority,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: feePayer,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: transferAuthority,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: TOKEN_PROGRAM_ID,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SYSVAR_RENT_PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SystemProgram.programId,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: VaultProgram.PUBKEY,
            data,
        }));
    }
}

var _a$l;
class CombineVaultArgs extends Data {
    constructor() {
        super(...arguments);
        this.instruction = VaultInstructions.CombineVault;
    }
}
_a$l = CombineVaultArgs;
CombineVaultArgs.SCHEMA = _a$l.struct([['instruction', 'u8']]);
class CombineVault extends Transaction {
    constructor(options, params) {
        super(options);
        const { vault, vaultAuthority, fractionMint, fractionTreasury, outstandingShareTokenAccount, payingTokenAccount, redeemTreasury, newVaultAuthority, transferAuthority, externalPriceAccount, burnAuthority, } = params;
        const data = CombineVaultArgs.serialize();
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: vault,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: outstandingShareTokenAccount,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: payingTokenAccount,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: fractionMint,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: fractionTreasury,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: redeemTreasury,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: newVaultAuthority || vaultAuthority,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: vaultAuthority,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: transferAuthority,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: burnAuthority,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: externalPriceAccount,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: TOKEN_PROGRAM_ID,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: VaultProgram.PUBKEY,
            data,
        }));
    }
}

var _a$k;
class InitVaultArgs extends Data {
    constructor() {
        super(...arguments);
        this.instruction = VaultInstructions.InitVault;
        this.allowFurtherShareCreation = false;
    }
}
_a$k = InitVaultArgs;
InitVaultArgs.SCHEMA = _a$k.struct([
    ['instruction', 'u8'],
    ['allowFurtherShareCreation', 'u8'],
]);
class InitVault extends Transaction {
    constructor(options, params) {
        super(options);
        const { vault, vaultAuthority, fractionalMint, redeemTreasury, fractionalTreasury, pricingLookupAddress, allowFurtherShareCreation, } = params;
        const data = InitVaultArgs.serialize({ allowFurtherShareCreation });
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: fractionalMint,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: redeemTreasury,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: fractionalTreasury,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: vault,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: vaultAuthority,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: pricingLookupAddress,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: TOKEN_PROGRAM_ID,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SYSVAR_RENT_PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: VaultProgram.PUBKEY,
            data,
        }));
    }
}

class MintFractionalShares extends Transaction {
    constructor(options, params) {
        super(options);
        const { vault, vaultAuthority, fractionMint, fractionTreasury, fractionMintAuthority, numberOfShares, } = params;
        const data = NumberOfShareArgs.serialize({
            instruction: VaultInstructions.MintFractionalShares,
            numberOfShares,
        });
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: fractionTreasury,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: fractionMint,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: vault,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: fractionMintAuthority,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: vaultAuthority,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: TOKEN_PROGRAM_ID,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: VaultProgram.PUBKEY,
            data,
        }));
    }
}

var _a$j;
class RedeemSharesArgs extends Data {
    constructor() {
        super(...arguments);
        this.instruction = VaultInstructions.RedeemShares;
    }
}
_a$j = RedeemSharesArgs;
RedeemSharesArgs.SCHEMA = _a$j.struct([['instruction', 'u8']]);
class RedeemShares extends Transaction {
    constructor(options, params) {
        super(options);
        const { vault, burnAuthority, fractionMint, outstandingSharesAccount, proceedsAccount, redeemTreasury, transferAuthority, } = params;
        const data = RedeemSharesArgs.serialize();
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: outstandingSharesAccount,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: proceedsAccount,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: fractionMint,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: redeemTreasury,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: transferAuthority,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: burnAuthority,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: vault,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: TOKEN_PROGRAM_ID,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SYSVAR_RENT_PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: VaultProgram.PUBKEY,
            data,
        }));
    }
}

var _a$i;
class SetVaultAuthorityArgs extends Data {
    constructor() {
        super(...arguments);
        this.instruction = VaultInstructions.SetVaultAuthority;
    }
}
_a$i = SetVaultAuthorityArgs;
SetVaultAuthorityArgs.SCHEMA = _a$i.struct([['instruction', 'u8']]);
class SetVaultAuthority extends Transaction {
    constructor(options, params) {
        super(options);
        const { vault, currentAuthority, newAuthority } = params;
        const data = SetVaultAuthorityArgs.serialize();
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: vault,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: currentAuthority,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: newAuthority,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: VaultProgram.PUBKEY,
            data,
        }));
    }
}

var _a$h;
class UpdateExternalPriceAccountArgs extends Data {
    constructor() {
        super(...arguments);
        this.instruction = VaultInstructions.UpdateExternalPriceAccount;
    }
}
_a$h = UpdateExternalPriceAccountArgs;
UpdateExternalPriceAccountArgs.SCHEMA = new Map([
    ...ExternalPriceAccountData.SCHEMA,
    ..._a$h.struct([
        ['instruction', 'u8'],
        ['externalPriceAccount', ExternalPriceAccountData],
    ]),
]);
class UpdateExternalPriceAccount extends Transaction {
    constructor(options, params) {
        super(options);
        const { externalPriceAccount, externalPriceAccountData } = params;
        const data = UpdateExternalPriceAccountArgs.serialize({
            externalPriceAccount: externalPriceAccountData,
        });
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: externalPriceAccount,
                    isSigner: false,
                    isWritable: true,
                },
            ],
            programId: VaultProgram.PUBKEY,
            data,
        }));
    }
}

class WithdrawSharesFromTreasury extends Transaction {
    constructor(options, params) {
        super(options);
        const { vault, vaultAuthority, destination, transferAuthority, fractionTreasury, numberOfShares, } = params;
        const data = NumberOfShareArgs.serialize({
            instruction: VaultInstructions.WithdrawSharesFromTreasury,
            numberOfShares,
        });
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: destination,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: fractionTreasury,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: vault,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: transferAuthority,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: vaultAuthority,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: TOKEN_PROGRAM_ID,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SYSVAR_RENT_PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: VaultProgram.PUBKEY,
            data,
        }));
    }
}

class WithdrawTokenFromSafetyDepositBox extends Transaction {
    constructor(options, params) {
        super(options);
        const { vault, vaultAuthority, store, destination, fractionMint, transferAuthority, safetyDepositBox, amount, } = params;
        const data = AmountArgs.serialize({
            instruction: VaultInstructions.WithdrawTokenFromSafetyDepositBox,
            amount,
        });
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: destination,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: safetyDepositBox,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: store,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: vault,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: fractionMint,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: vaultAuthority,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: transferAuthority,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: TOKEN_PROGRAM_ID,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SYSVAR_RENT_PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: VaultProgram.PUBKEY,
            data,
        }));
    }
}

var index$4 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  SafetyDepositBoxData: SafetyDepositBoxData,
  SafetyDepositBox: SafetyDepositBox,
  AmountArgs: AmountArgs,
  NumberOfShareArgs: NumberOfShareArgs,
  get VaultState () { return VaultState; },
  VaultData: VaultData,
  Vault: Vault,
  ExternalPriceAccountData: ExternalPriceAccountData,
  ExternalPriceAccount: ExternalPriceAccount,
  get VaultKey () { return VaultKey; },
  get VaultInstructions () { return VaultInstructions; },
  VaultProgram: VaultProgram,
  ActivateVault: ActivateVault,
  AddSharesToTreasury: AddSharesToTreasury,
  AddTokenToInactiveVault: AddTokenToInactiveVault,
  CombineVaultArgs: CombineVaultArgs,
  CombineVault: CombineVault,
  InitVaultArgs: InitVaultArgs,
  InitVault: InitVault,
  MintFractionalShares: MintFractionalShares,
  RedeemSharesArgs: RedeemSharesArgs,
  RedeemShares: RedeemShares,
  SetVaultAuthorityArgs: SetVaultAuthorityArgs,
  SetVaultAuthority: SetVaultAuthority,
  UpdateExternalPriceAccountArgs: UpdateExternalPriceAccountArgs,
  UpdateExternalPriceAccount: UpdateExternalPriceAccount,
  WithdrawSharesFromTreasury: WithdrawSharesFromTreasury,
  WithdrawTokenFromSafetyDepositBox: WithdrawTokenFromSafetyDepositBox
});

var MetadataKey;
(function (MetadataKey) {
    MetadataKey[MetadataKey["Uninitialized"] = 0] = "Uninitialized";
    MetadataKey[MetadataKey["MetadataV1"] = 4] = "MetadataV1";
    MetadataKey[MetadataKey["EditionV1"] = 1] = "EditionV1";
    MetadataKey[MetadataKey["MasterEditionV1"] = 2] = "MasterEditionV1";
    MetadataKey[MetadataKey["MasterEditionV2"] = 6] = "MasterEditionV2";
    MetadataKey[MetadataKey["EditionMarker"] = 7] = "EditionMarker";
})(MetadataKey || (MetadataKey = {}));
class MetadataProgram extends Program {
}
MetadataProgram.PREFIX = 'metadata';
MetadataProgram.PUBKEY = new PublicKey(config.programs.metadata);

var _a$g;
class EditionData extends Data {
    constructor(args) {
        super(args);
        this.key = MetadataKey.EditionV1;
    }
}
_a$g = EditionData;
EditionData.SCHEMA = _a$g.struct([
    ['key', 'u8'],
    ['parent', 'pubkeyAsString'],
    ['edition', 'u64'],
]);
class Edition extends Account {
    constructor(key, info) {
        super(key, info);
        if (!this.assertOwner(MetadataProgram.PUBKEY)) {
            throw ERROR_INVALID_OWNER();
        }
        if (!Edition.isCompatible(this.info.data)) {
            throw ERROR_INVALID_ACCOUNT_DATA();
        }
        this.data = EditionData.deserialize(this.info.data);
    }
    static getPDA(mint) {
        return __awaiter(this, void 0, void 0, function* () {
            return MetadataProgram.findProgramAddress([
                Buffer$1.from(MetadataProgram.PREFIX),
                MetadataProgram.PUBKEY.toBuffer(),
                new PublicKey(mint).toBuffer(),
                Buffer$1.from(Edition.EDITION_PREFIX),
            ]);
        });
    }
    static isCompatible(data) {
        return data[0] === MetadataKey.EditionV1;
    }
}
Edition.EDITION_PREFIX = 'edition';

var _a$f;
class EditionMarkerData extends Data {
    constructor(args) {
        super(args);
        this.key = MetadataKey.EditionMarker;
    }
    editionTaken(edition) {
        const editionOffset = edition % EditionMarker.DATA_SIZE;
        const indexOffset = Math.floor(editionOffset / 8);
        if (indexOffset > 30) {
            throw Error('Bad index for edition');
        }
        const positionInBitsetFromRight = 7 - (editionOffset % 8);
        const mask = Math.pow(2, positionInBitsetFromRight);
        const appliedMask = this.ledger[indexOffset] & mask;
        return appliedMask != 0;
    }
}
_a$f = EditionMarkerData;
EditionMarkerData.SCHEMA = _a$f.struct([
    ['key', 'u8'],
    ['ledger', [31]],
]);
class EditionMarker extends Account {
    constructor(key, info) {
        super(key, info);
        if (!this.assertOwner(MetadataProgram.PUBKEY)) {
            throw ERROR_INVALID_OWNER();
        }
        if (!EditionMarker.isCompatible(this.info.data)) {
            throw ERROR_INVALID_ACCOUNT_DATA();
        }
        this.data = EditionMarkerData.deserialize(this.info.data);
    }
    static getPDA(mint, edition) {
        return __awaiter(this, void 0, void 0, function* () {
            const editionNumber = Math.floor(edition.toNumber() / 248);
            return MetadataProgram.findProgramAddress([
                Buffer$1.from(MetadataProgram.PREFIX),
                MetadataProgram.PUBKEY.toBuffer(),
                new PublicKey(mint).toBuffer(),
                Buffer$1.from(Edition.EDITION_PREFIX),
                Buffer$1.from(editionNumber.toString()),
            ]);
        });
    }
    static isCompatible(data) {
        return data[0] === MetadataKey.EditionMarker;
    }
}
EditionMarker.DATA_SIZE = 248;

var _a$e, _b$2;
class MasterEditionV1Data extends Data {
    constructor(args) {
        super(args);
        this.key = MetadataKey.MasterEditionV1;
    }
}
_a$e = MasterEditionV1Data;
MasterEditionV1Data.SCHEMA = _a$e.struct([
    ['key', 'u8'],
    ['supply', 'u64'],
    ['maxSupply', { kind: 'option', type: 'u64' }],
    ['printingMint', 'pubkeyAsString'],
    ['oneTimePrintingAuthorizationMint', 'pubkeyAsString'],
]);
class MasterEditionV2Data extends Data {
    constructor(args) {
        super(args);
        this.key = MetadataKey.MasterEditionV2;
    }
}
_b$2 = MasterEditionV2Data;
MasterEditionV2Data.SCHEMA = _b$2.struct([
    ['key', 'u8'],
    ['supply', 'u64'],
    ['maxSupply', { kind: 'option', type: 'u64' }],
]);
class MasterEdition extends Account {
    constructor(key, info) {
        super(key, info);
        if (!this.assertOwner(MetadataProgram.PUBKEY)) {
            throw ERROR_INVALID_OWNER();
        }
        if (MasterEdition.isMasterEditionV1(this.info.data)) {
            this.data = MasterEditionV1Data.deserialize(this.info.data);
        }
        else if (MasterEdition.isMasterEditionV2(this.info.data)) {
            this.data = MasterEditionV2Data.deserialize(this.info.data);
        }
        else {
            throw ERROR_INVALID_ACCOUNT_DATA();
        }
    }
    static getPDA(mint) {
        return __awaiter(this, void 0, void 0, function* () {
            return MetadataProgram.findProgramAddress([
                Buffer$1.from(MetadataProgram.PREFIX),
                MetadataProgram.PUBKEY.toBuffer(),
                new PublicKey(mint).toBuffer(),
                Buffer$1.from(MasterEdition.EDITION_PREFIX),
            ]);
        });
    }
    static isCompatible(data) {
        return MasterEdition.isMasterEditionV1(data) || MasterEdition.isMasterEditionV2(data);
    }
    static isMasterEditionV1(data) {
        return data[0] === MetadataKey.MasterEditionV1;
    }
    static isMasterEditionV2(data) {
        return data[0] === MetadataKey.MasterEditionV2;
    }
    getEditions(connection) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield MetadataProgram.getProgramAccounts(connection, {
                filters: [
                    {
                        memcmp: {
                            offset: 0,
                            bytes: bs58.encode(Buffer$1.from([MetadataKey.EditionV1])),
                        },
                    },
                    {
                        memcmp: {
                            offset: 1,
                            bytes: this.pubkey.toBase58(),
                        },
                    },
                ],
            })).map((account) => Edition.from(account));
        });
    }
}
MasterEdition.EDITION_PREFIX = 'edition';

class TokenAccount extends Account {
    constructor(pubkey, info) {
        super(pubkey, info);
        if (!this.assertOwner(TOKEN_PROGRAM_ID)) {
            throw ERROR_INVALID_OWNER();
        }
        if (!TokenAccount.isCompatible(this.info.data)) {
            throw ERROR_INVALID_ACCOUNT_DATA();
        }
        this.data = deserialize(this.info.data);
    }
    static isCompatible(data) {
        return data.length === AccountLayout.span;
    }
    static getTokenAccountsByOwner(connection, owner) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield connection.getTokenAccountsByOwner(new PublicKey(owner), {
                programId: TOKEN_PROGRAM_ID,
            })).value.map(({ pubkey, account }) => new TokenAccount(pubkey, account));
        });
    }
}
const deserialize = (data) => {
    const accountInfo = AccountLayout.decode(data);
    accountInfo.mint = new PublicKey(accountInfo.mint);
    accountInfo.owner = new PublicKey(accountInfo.owner);
    accountInfo.amount = u64.fromBuffer(accountInfo.amount);
    if (accountInfo.delegateOption === 0) {
        accountInfo.delegate = null;
        accountInfo.delegatedAmount = new u64(0);
    }
    else {
        accountInfo.delegate = new PublicKey(accountInfo.delegate);
        accountInfo.delegatedAmount = u64.fromBuffer(accountInfo.delegatedAmount);
    }
    accountInfo.isInitialized = accountInfo.state !== 0;
    accountInfo.isFrozen = accountInfo.state === 2;
    if (accountInfo.isNativeOption === 1) {
        accountInfo.rentExemptReserve = u64.fromBuffer(accountInfo.isNative);
        accountInfo.isNative = true;
    }
    else {
        accountInfo.rentExemptReserve = null;
        accountInfo.isNative = false;
    }
    if (accountInfo.closeAuthorityOption === 0) {
        accountInfo.closeAuthority = null;
    }
    else {
        accountInfo.closeAuthority = new PublicKey(accountInfo.closeAuthority);
    }
    return accountInfo;
};

class PayForFiles extends Transaction {
    constructor(options, params) {
        const { feePayer } = options;
        const { lamports, fileHashes, arweaveWallet } = params;
        super(options);
        this.add(SystemProgram.transfer({
            fromPubkey: feePayer,
            toPubkey: arweaveWallet !== null && arweaveWallet !== void 0 ? arweaveWallet : new PublicKey(config.arweaveWallet),
            lamports,
        }));
        fileHashes.forEach((data) => {
            this.add(new TransactionInstruction({
                keys: [],
                programId: new PublicKey(config.programs.memo),
                data,
            }));
        });
    }
}

class CreateMint extends Transaction {
    constructor(options, params) {
        const { feePayer } = options;
        const { newAccountPubkey, lamports, decimals, owner, freezeAuthority } = params;
        super(options);
        this.add(SystemProgram.createAccount({
            fromPubkey: feePayer,
            newAccountPubkey,
            lamports,
            space: MintLayout.span,
            programId: TOKEN_PROGRAM_ID,
        }));
        this.add(Token.createInitMintInstruction(TOKEN_PROGRAM_ID, newAccountPubkey, decimals !== null && decimals !== void 0 ? decimals : 0, owner !== null && owner !== void 0 ? owner : feePayer, freezeAuthority !== null && freezeAuthority !== void 0 ? freezeAuthority : feePayer));
    }
}

class CreateTokenAccount extends Transaction {
    constructor(options, params) {
        const { feePayer } = options;
        const { newAccountPubkey, lamports, mint, owner } = params;
        super(options);
        this.add(SystemProgram.createAccount({
            fromPubkey: feePayer,
            newAccountPubkey,
            lamports,
            space: AccountLayout.span,
            programId: TOKEN_PROGRAM_ID,
        }));
        this.add(Token.createInitAccountInstruction(TOKEN_PROGRAM_ID, mint, newAccountPubkey, owner !== null && owner !== void 0 ? owner : feePayer));
    }
}

class CreateAssociatedTokenAccount extends Transaction {
    constructor(options, params) {
        const { feePayer } = options;
        const { associatedTokenAddress, walletAddress, splTokenMintAddress } = params;
        super(options);
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: feePayer,
                    isSigner: true,
                    isWritable: true,
                },
                {
                    pubkey: associatedTokenAddress,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: walletAddress !== null && walletAddress !== void 0 ? walletAddress : feePayer,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: splTokenMintAddress,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SystemProgram.programId,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: TOKEN_PROGRAM_ID,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SYSVAR_RENT_PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: ASSOCIATED_TOKEN_PROGRAM_ID,
            data: Buffer$1.from([]),
        }));
    }
}

class MintTo extends Transaction {
    constructor(options, params) {
        const { feePayer } = options;
        const { mint, dest, authority, amount } = params;
        super(options);
        this.add(Token.createMintToInstruction(TOKEN_PROGRAM_ID, mint, dest, authority !== null && authority !== void 0 ? authority : feePayer, [], new BN(amount).toNumber()));
    }
}

var _a$d, _b$1, _c;
class Creator extends Data {
}
_a$d = Creator;
Creator.SCHEMA = _a$d.struct([
    ['address', 'pubkeyAsString'],
    ['verified', 'u8'],
    ['share', 'u8'],
]);
class MetadataDataData extends Data {
    constructor(args) {
        super(args);
        const METADATA_REPLACE = new RegExp('\u0000', 'g');
        this.name = args.name.replace(METADATA_REPLACE, '');
        this.uri = args.uri.replace(METADATA_REPLACE, '');
        this.symbol = args.symbol.replace(METADATA_REPLACE, '');
    }
}
_b$1 = MetadataDataData;
MetadataDataData.SCHEMA = new Map([
    ...Creator.SCHEMA,
    ..._b$1.struct([
        ['name', 'string'],
        ['symbol', 'string'],
        ['uri', 'string'],
        ['sellerFeeBasisPoints', 'u16'],
        ['creators', { kind: 'option', type: [Creator] }],
    ]),
]);
class MetadataData extends Data {
    constructor(args) {
        super(args);
        this.key = MetadataKey.MetadataV1;
    }
}
_c = MetadataData;
MetadataData.SCHEMA = new Map([
    ...MetadataDataData.SCHEMA,
    ..._c.struct([
        ['key', 'u8'],
        ['updateAuthority', 'pubkeyAsString'],
        ['mint', 'pubkeyAsString'],
        ['data', MetadataDataData],
        ['primarySaleHappened', 'u8'],
        ['isMutable', 'u8'],
    ]),
]);
class Metadata extends Account {
    constructor(pubkey, info) {
        super(pubkey, info);
        if (!this.assertOwner(MetadataProgram.PUBKEY)) {
            throw ERROR_INVALID_OWNER();
        }
        if (!Metadata.isCompatible(this.info.data)) {
            throw ERROR_INVALID_ACCOUNT_DATA();
        }
        this.data = MetadataData.deserialize(this.info.data);
    }
    static isCompatible(data) {
        return data[0] === MetadataKey.MetadataV1;
    }
    static getPDA(mint) {
        return __awaiter(this, void 0, void 0, function* () {
            return MetadataProgram.findProgramAddress([
                Buffer$1.from(MetadataProgram.PREFIX),
                MetadataProgram.PUBKEY.toBuffer(),
                new PublicKey(mint).toBuffer(),
            ]);
        });
    }
    static findMany(connection, filters = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const baseFilters = [
                {
                    memcmp: {
                        offset: 0,
                        bytes: bs58.encode(Buffer$1.from([MetadataKey.MetadataV1])),
                    },
                },
                filters.updateAuthority && {
                    memcmp: {
                        offset: 1,
                        bytes: new PublicKey(filters.updateAuthority).toBase58(),
                    },
                },
                filters.mint && {
                    memcmp: {
                        offset: 33,
                        bytes: new PublicKey(filters.mint).toBase58(),
                    },
                },
            ].filter(Boolean);
            if (filters.creators) {
                return (yield Promise.all(Array.from(Array(config.maxCreatorLimit).keys()).reduce((prev, i) => [
                    ...prev,
                    ...filters.creators.map((pubkey) => MetadataProgram.getProgramAccounts(connection, {
                        filters: [
                            ...baseFilters,
                            {
                                memcmp: {
                                    offset: computeCreatorOffset(i),
                                    bytes: new PublicKey(pubkey).toBase58(),
                                },
                            },
                        ],
                    })),
                ], [])))
                    .flat()
                    .map((account) => Metadata.from(account));
            }
            else {
                return (yield MetadataProgram.getProgramAccounts(connection, { filters: baseFilters })).map((account) => Metadata.from(account));
            }
        });
    }
    static findByOwner(connection, owner) {
        return __awaiter(this, void 0, void 0, function* () {
            const accounts = yield TokenAccount.getTokenAccountsByOwner(connection, owner);
            const accountMap = new Map(accounts.map(({ data }) => [data.mint.toString(), data]));
            const allMetadata = yield Metadata.findMany(connection);
            return allMetadata.filter((metadata) => {
                var _d, _e;
                return accountMap.has(metadata.data.mint) &&
                    (((_e = (_d = accountMap === null || accountMap === void 0 ? void 0 : accountMap.get(metadata.data.mint)) === null || _d === void 0 ? void 0 : _d.amount) === null || _e === void 0 ? void 0 : _e.toNumber()) || 0) > 0;
            });
        });
    }
    static findByOwnerV2(connection, owner) {
        return __awaiter(this, void 0, void 0, function* () {
            const accounts = yield TokenAccount.getTokenAccountsByOwner(connection, owner);
            const accountsWithAmount = accounts
                .map(({ data }) => data)
                .filter(({ amount }) => (amount === null || amount === void 0 ? void 0 : amount.toNumber()) > 0);
            return (yield Promise.all(accountsWithAmount.map(({ mint }) => Metadata.findMany(connection, { mint })))).flat();
        });
    }
    static findDataByOwner(connection, owner) {
        return __awaiter(this, void 0, void 0, function* () {
            const accounts = yield TokenAccount.getTokenAccountsByOwner(connection, owner);
            const metadataPdaLookups = accounts.reduce((memo, { data }) => {
                var _d;
                return ((_d = data.amount) === null || _d === void 0 ? void 0 : _d.eq(new BN(1))) ? [...memo, Metadata.getPDA(data.mint)] : memo;
            }, []);
            const metadataAddresses = yield Promise.all(metadataPdaLookups);
            const tokenInfo = yield Account.getInfos(connection, metadataAddresses);
            return Array.from(tokenInfo.values()).map((m) => MetadataData.deserialize(m.data));
        });
    }
    static getEdition(connection, mint) {
        return __awaiter(this, void 0, void 0, function* () {
            const pda = yield Edition.getPDA(mint);
            const info = yield Account.getInfo(connection, pda);
            const key = info === null || info === void 0 ? void 0 : info.data[0];
            switch (key) {
                case MetadataKey.EditionV1:
                    return new Edition(pda, info);
                case MetadataKey.MasterEditionV1:
                case MetadataKey.MasterEditionV2:
                    return new MasterEdition(pda, info);
                default:
                    return;
            }
        });
    }
}
const MAX_NAME_LENGTH = 32;
const MAX_SYMBOL_LENGTH = 10;
const MAX_URI_LENGTH = 200;
const MAX_CREATOR_LEN = 32 + 1 + 1;
const computeCreatorOffset = (index) => {
    return (1 +
        32 +
        32 +
        4 +
        MAX_NAME_LENGTH +
        4 +
        MAX_URI_LENGTH +
        4 +
        MAX_SYMBOL_LENGTH +
        2 +
        1 +
        4 +
        index * MAX_CREATOR_LEN);
};

var _a$c;
class CreateMetadataArgs extends Data {
    constructor() {
        super(...arguments);
        this.instruction = 0;
    }
}
_a$c = CreateMetadataArgs;
CreateMetadataArgs.SCHEMA = new Map([
    ...MetadataDataData.SCHEMA,
    ..._a$c.struct([
        ['instruction', 'u8'],
        ['data', MetadataDataData],
        ['isMutable', 'u8'],
    ]),
]);
class CreateMetadata extends Transaction {
    constructor(options, params) {
        super(options);
        const { feePayer } = options;
        const { metadata, metadataData, updateAuthority, mint, mintAuthority } = params;
        const data = CreateMetadataArgs.serialize({
            data: metadataData,
            isMutable: true,
        });
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: metadata,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: mint,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: mintAuthority,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: feePayer,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: updateAuthority,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SystemProgram.programId,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SYSVAR_RENT_PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: MetadataProgram.PUBKEY,
            data,
        }));
    }
}

var _a$b;
class UpdateMetadataArgs extends Data {
    constructor() {
        super(...arguments);
        this.instruction = 1;
    }
}
_a$b = UpdateMetadataArgs;
UpdateMetadataArgs.SCHEMA = new Map([
    ...MetadataDataData.SCHEMA,
    ..._a$b.struct([
        ['instruction', 'u8'],
        ['data', { kind: 'option', type: MetadataDataData }],
        ['updateAuthority', { kind: 'option', type: 'pubkeyAsString' }],
        ['primarySaleHappened', { kind: 'option', type: 'u8' }],
    ]),
]);
class UpdateMetadata extends Transaction {
    constructor(options, params) {
        super(options);
        const { metadata, metadataData, updateAuthority, newUpdateAuthority, primarySaleHappened } = params;
        const data = UpdateMetadataArgs.serialize({
            data: metadataData,
            updateAuthority: newUpdateAuthority && newUpdateAuthority.toString(),
            primarySaleHappened: primarySaleHappened || null,
        });
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: metadata,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: updateAuthority,
                    isSigner: true,
                    isWritable: false,
                },
            ],
            programId: MetadataProgram.PUBKEY,
            data,
        }));
    }
}

var _a$a;
class CreateMasterEditionArgs extends Data {
    constructor() {
        super(...arguments);
        this.instruction = 10;
    }
}
_a$a = CreateMasterEditionArgs;
CreateMasterEditionArgs.SCHEMA = _a$a.struct([
    ['instruction', 'u8'],
    ['maxSupply', { kind: 'option', type: 'u64' }],
]);
class CreateMasterEdition extends Transaction {
    constructor(options, params) {
        super(options);
        const { feePayer } = options;
        const { edition, metadata, updateAuthority, mint, mintAuthority, maxSupply } = params;
        const data = CreateMasterEditionArgs.serialize({
            maxSupply: maxSupply || null,
        });
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: edition,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: mint,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: updateAuthority,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: mintAuthority,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: feePayer,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: metadata,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: TOKEN_PROGRAM_ID,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SystemProgram.programId,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SYSVAR_RENT_PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: MetadataProgram.PUBKEY,
            data,
        }));
    }
}

var _a$9;
class MintNewEditionFromMasterEditionViaTokenArgs extends Data {
    constructor() {
        super(...arguments);
        this.instruction = 11;
    }
}
_a$9 = MintNewEditionFromMasterEditionViaTokenArgs;
MintNewEditionFromMasterEditionViaTokenArgs.SCHEMA = _a$9.struct([
    ['instruction', 'u8'],
    ['edition', 'u64'],
]);
class MintNewEditionFromMasterEditionViaToken extends Transaction {
    constructor(options, params) {
        super(options);
        const { feePayer } = options;
        const { edition, metadata, updateAuthority, masterEdition, masterMetadata, mint, editionMarker, mintAuthority, tokenOwner, tokenAccount, editionValue, } = params;
        const data = MintNewEditionFromMasterEditionViaTokenArgs.serialize({
            edition: editionValue,
        });
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: metadata,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: edition,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: masterEdition,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: mint,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: editionMarker,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: mintAuthority,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: feePayer,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: tokenOwner,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: tokenAccount,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: updateAuthority,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: masterMetadata,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: TOKEN_PROGRAM_ID,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SystemProgram.programId,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SYSVAR_RENT_PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: MetadataProgram.PUBKEY,
            data,
        }));
    }
}

var _a$8;
class UpdatePrimarySaleHappenedViaTokenArgs extends Data {
    constructor() {
        super(...arguments);
        this.instruction = 4;
    }
}
_a$8 = UpdatePrimarySaleHappenedViaTokenArgs;
UpdatePrimarySaleHappenedViaTokenArgs.SCHEMA = _a$8.struct([['instruction', 'u8']]);
class UpdatePrimarySaleHappenedViaToken extends Transaction {
    constructor(options, params) {
        super(options);
        const { metadata, owner, tokenAccount } = params;
        const data = UpdatePrimarySaleHappenedViaTokenArgs.serialize();
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: metadata,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: owner,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: tokenAccount,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: MetadataProgram.PUBKEY,
            data,
        }));
    }
}

var _a$7;
class SignMetadataArgs extends Data {
    constructor() {
        super(...arguments);
        this.instruction = 7;
    }
}
_a$7 = SignMetadataArgs;
SignMetadataArgs.SCHEMA = _a$7.struct([['instruction', 'u8']]);
class SignMetadata extends Transaction {
    constructor(options, params) {
        super(options);
        const { metadata, creator } = params;
        const data = SignMetadataArgs.serialize();
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: metadata,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: creator,
                    isSigner: true,
                    isWritable: false,
                },
            ],
            programId: MetadataProgram.PUBKEY,
            data,
        }));
    }
}

var index$3 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  EditionData: EditionData,
  Edition: Edition,
  EditionMarkerData: EditionMarkerData,
  EditionMarker: EditionMarker,
  MasterEditionV1Data: MasterEditionV1Data,
  MasterEditionV2Data: MasterEditionV2Data,
  MasterEdition: MasterEdition,
  Creator: Creator,
  MetadataDataData: MetadataDataData,
  MetadataData: MetadataData,
  Metadata: Metadata,
  MAX_NAME_LENGTH: MAX_NAME_LENGTH,
  MAX_SYMBOL_LENGTH: MAX_SYMBOL_LENGTH,
  MAX_URI_LENGTH: MAX_URI_LENGTH,
  MAX_CREATOR_LEN: MAX_CREATOR_LEN,
  computeCreatorOffset: computeCreatorOffset,
  get MetadataKey () { return MetadataKey; },
  MetadataProgram: MetadataProgram,
  CreateMetadataArgs: CreateMetadataArgs,
  CreateMetadata: CreateMetadata,
  UpdateMetadataArgs: UpdateMetadataArgs,
  UpdateMetadata: UpdateMetadata,
  CreateMasterEditionArgs: CreateMasterEditionArgs,
  CreateMasterEdition: CreateMasterEdition,
  MintNewEditionFromMasterEditionViaTokenArgs: MintNewEditionFromMasterEditionViaTokenArgs,
  MintNewEditionFromMasterEditionViaToken: MintNewEditionFromMasterEditionViaToken,
  UpdatePrimarySaleHappenedViaTokenArgs: UpdatePrimarySaleHappenedViaTokenArgs,
  UpdatePrimarySaleHappenedViaToken: UpdatePrimarySaleHappenedViaToken,
  SignMetadataArgs: SignMetadataArgs,
  SignMetadata: SignMetadata
});

var _a$6;
class SetStoreArgs extends Data {
    constructor() {
        super(...arguments);
        this.instruction = 8;
    }
}
_a$6 = SetStoreArgs;
SetStoreArgs.SCHEMA = _a$6.struct([
    ['instruction', 'u8'],
    ['public', 'u8'],
]);
class SetStore extends Transaction {
    constructor(options, params) {
        super(options);
        const { feePayer } = options;
        const { admin, store, isPublic } = params;
        const data = SetStoreArgs.serialize({ public: isPublic });
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: store,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: admin,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: feePayer,
                    isSigner: true,
                    isWritable: false,
                },
                { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
                {
                    pubkey: VaultProgram.PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: MetadataProgram.PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: AuctionProgram.PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SystemProgram.programId,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SYSVAR_RENT_PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: MetaplexProgram.PUBKEY,
            data,
        }));
    }
}

var _a$5;
class SetWhitelistedCreatorArgs extends Data {
    constructor() {
        super(...arguments);
        this.instruction = 9;
    }
}
_a$5 = SetWhitelistedCreatorArgs;
SetWhitelistedCreatorArgs.SCHEMA = _a$5.struct([
    ['instruction', 'u8'],
    ['activated', 'u8'],
]);
class SetWhitelistedCreator extends Transaction {
    constructor(options, params) {
        super(options);
        const { feePayer } = options;
        const { admin, whitelistedCreatorPDA, store, creator, activated } = params;
        const data = SetWhitelistedCreatorArgs.serialize({ activated });
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: whitelistedCreatorPDA,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: admin,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: feePayer,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: creator,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: store,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SystemProgram.programId,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SYSVAR_RENT_PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: MetaplexProgram.PUBKEY,
            data,
        }));
    }
}

var _a$4;
class StartAuctionArgs extends Data {
    constructor() {
        super(...arguments);
        this.instruction = 5;
    }
}
_a$4 = StartAuctionArgs;
StartAuctionArgs.SCHEMA = _a$4.struct([['instruction', 'u8']]);
class StartAuction extends Transaction {
    constructor(options, params) {
        super(options);
        const { store, auction, auctionManager, auctionManagerAuthority } = params;
        const data = StartAuctionArgs.serialize();
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: auctionManager,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: auction,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: auctionManagerAuthority,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: store,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: AuctionProgram.PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SYSVAR_CLOCK_PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: MetaplexProgram.PUBKEY,
            data,
        }));
    }
}

var _a$3;
class InitAuctionManagerV2Args extends Data {
    constructor() {
        super(...arguments);
        this.instruction = 17;
        this.amountType = TupleNumericType.U8;
        this.lengthType = TupleNumericType.U8;
        this.maxRanges = new BN(1);
    }
}
_a$3 = InitAuctionManagerV2Args;
InitAuctionManagerV2Args.SCHEMA = _a$3.struct([
    ['instruction', 'u8'],
    ['amountType', 'u8'],
    ['lengthType', 'u8'],
    ['maxRanges', 'u64'],
]);
class InitAuctionManagerV2 extends Transaction {
    constructor(options, params) {
        super(options);
        const { feePayer } = options;
        const { store, vault, auction, auctionManager, auctionManagerAuthority, acceptPaymentAccount, tokenTracker, amountType, lengthType, maxRanges, } = params;
        const data = InitAuctionManagerV2Args.serialize({ amountType, lengthType, maxRanges });
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: auctionManager,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: tokenTracker,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: vault,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: auction,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: auctionManagerAuthority,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: feePayer,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: acceptPaymentAccount,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: store,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SystemProgram.programId,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SYSVAR_RENT_PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: MetaplexProgram.PUBKEY,
            data,
        }));
    }
}

var _a$2;
class ClaimBidArgs extends Data {
    constructor() {
        super(...arguments);
        this.instruction = 6;
    }
}
_a$2 = ClaimBidArgs;
ClaimBidArgs.SCHEMA = _a$2.struct([['instruction', 'u8']]);
class ClaimBid extends Transaction {
    constructor(options, params) {
        super(options);
        const { store, vault, auction, auctionExtended, auctionManager, bidder, bidderPot, bidderPotToken, acceptPayment, tokenMint, } = params;
        const data = ClaimBidArgs.serialize();
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: acceptPayment,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: bidderPotToken,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: bidderPot,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: auctionManager,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: auction,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: bidder,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: tokenMint,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: vault,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: store,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: AuctionProgram.PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SYSVAR_CLOCK_PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: TOKEN_PROGRAM_ID,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: auctionExtended,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: MetaplexProgram.PUBKEY,
            data,
        }));
    }
}

var _a$1, _b;
class RedeemBidArgs extends Data {
    constructor() {
        super(...arguments);
        this.instruction = 2;
    }
}
_a$1 = RedeemBidArgs;
RedeemBidArgs.SCHEMA = _a$1.struct([['instruction', 'u8']]);
var ProxyCallAddress;
(function (ProxyCallAddress) {
    ProxyCallAddress[ProxyCallAddress["RedeemBid"] = 0] = "RedeemBid";
    ProxyCallAddress[ProxyCallAddress["RedeemFullRightsTransferBid"] = 1] = "RedeemFullRightsTransferBid";
})(ProxyCallAddress || (ProxyCallAddress = {}));
class RedeemUnusedWinningConfigItemsAsAuctioneerArgs extends Data {
    constructor() {
        super(...arguments);
        this.instruction = 12;
    }
}
_b = RedeemUnusedWinningConfigItemsAsAuctioneerArgs;
RedeemUnusedWinningConfigItemsAsAuctioneerArgs.SCHEMA = _b.struct([
    ['instruction', 'u8'],
    ['winningConfigItemIndex', 'u8'],
    ['proxyCall', 'u8'],
]);
class RedeemBid extends Transaction {
    constructor(options, params) {
        super(options);
        const { feePayer } = options;
        const { store, vault, auction, auctionExtended, auctionManager, bidRedemption, bidderMeta: bidMetadata, safetyDepositTokenStore, destination, safetyDeposit, fractionMint, bidder, isPrintingType, safetyDepositConfig, transferAuthority, masterEdition, reservationList, auctioneerReclaimIndex, } = params;
        const data = auctioneerReclaimIndex
            ? RedeemUnusedWinningConfigItemsAsAuctioneerArgs.serialize({
                winningConfigItemIndex: auctioneerReclaimIndex,
                proxyCall: ProxyCallAddress.RedeemBid,
            })
            : RedeemBidArgs.serialize();
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: auctionManager,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: safetyDepositTokenStore,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: destination,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: bidRedemption,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: safetyDeposit,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: vault,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: fractionMint,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: auction,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: bidMetadata,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: bidder,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: feePayer,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: TOKEN_PROGRAM_ID,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: VaultProgram.PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: MetadataProgram.PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: store,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SystemProgram.programId,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SYSVAR_RENT_PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: transferAuthority,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: safetyDepositConfig,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: auctionExtended,
                    isSigner: false,
                    isWritable: false,
                },
                ...(isPrintingType && masterEdition && reservationList
                    ? [
                        {
                            pubkey: masterEdition,
                            isSigner: false,
                            isWritable: true,
                        },
                        {
                            pubkey: reservationList,
                            isSigner: false,
                            isWritable: true,
                        },
                    ]
                    : []),
            ],
            programId: MetaplexProgram.PUBKEY,
            data,
        }));
    }
}

var _a;
class RedeemFullRightsTransferBidArgs extends Data {
    constructor() {
        super(...arguments);
        this.instruction = 3;
    }
}
_a = RedeemFullRightsTransferBidArgs;
RedeemFullRightsTransferBidArgs.SCHEMA = _a.struct([['instruction', 'u8']]);
class RedeemFullRightsTransferBid extends Transaction {
    constructor(options, params) {
        super(options);
        const { feePayer } = options;
        const { store, vault, auction, auctionExtended, auctionManager, bidRedemption, bidMetadata, safetyDepositTokenStore, destination, safetyDeposit, fractionMint, bidder, safetyDepositConfig, transferAuthority, masterMetadata, newAuthority, auctioneerReclaimIndex, } = params;
        const data = auctioneerReclaimIndex
            ? RedeemUnusedWinningConfigItemsAsAuctioneerArgs.serialize({
                winningConfigItemIndex: auctioneerReclaimIndex,
                proxyCall: ProxyCallAddress.RedeemFullRightsTransferBid,
            })
            : RedeemFullRightsTransferBidArgs.serialize();
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: auctionManager,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: safetyDepositTokenStore,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: destination,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: bidRedemption,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: safetyDeposit,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: vault,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: fractionMint,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: auction,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: bidMetadata,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: bidder,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: feePayer,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: TOKEN_PROGRAM_ID,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: VaultProgram.PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: MetadataProgram.PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: store,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SystemProgram.programId,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SYSVAR_RENT_PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: masterMetadata,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: newAuthority,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: transferAuthority,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: safetyDepositConfig,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: auctionExtended,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: MetaplexProgram.PUBKEY,
            data,
        }));
    }
}

var index$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  get AuctionManagerStatus () { return AuctionManagerStatus; },
  AuctionManagerStateV2: AuctionManagerStateV2,
  AuctionManagerV2Data: AuctionManagerV2Data,
  AuctionManager: AuctionManager,
  WINNER_INDEX_OFFSETS: WINNER_INDEX_OFFSETS,
  BidRedemptionTicket: BidRedemptionTicket,
  PayoutTicketData: PayoutTicketData,
  PayoutTicket: PayoutTicket,
  PrizeTrackingTicketData: PrizeTrackingTicketData,
  PrizeTrackingTicket: PrizeTrackingTicket,
  get WinningConfigType () { return WinningConfigType; },
  get WinningConstraint () { return WinningConstraint; },
  get NonWinningConstraint () { return NonWinningConstraint; },
  SafetyDepositConfig: SafetyDepositConfig,
  StoreData: StoreData,
  Store: Store,
  WhitelistedCreatorData: WhitelistedCreatorData,
  WhitelistedCreator: WhitelistedCreator,
  AuctionWinnerTokenTypeTracker: AuctionWinnerTokenTypeTracker,
  get MetaplexKey () { return MetaplexKey; },
  MetaplexProgram: MetaplexProgram,
  SetStoreArgs: SetStoreArgs,
  SetStore: SetStore,
  SetWhitelistedCreatorArgs: SetWhitelistedCreatorArgs,
  SetWhitelistedCreator: SetWhitelistedCreator,
  StartAuctionArgs: StartAuctionArgs,
  StartAuction: StartAuction,
  InitAuctionManagerV2Args: InitAuctionManagerV2Args,
  InitAuctionManagerV2: InitAuctionManagerV2,
  ClaimBidArgs: ClaimBidArgs,
  ClaimBid: ClaimBid,
  RedeemBidArgs: RedeemBidArgs,
  get ProxyCallAddress () { return ProxyCallAddress; },
  RedeemUnusedWinningConfigItemsAsAuctioneerArgs: RedeemUnusedWinningConfigItemsAsAuctioneerArgs,
  RedeemBid: RedeemBid,
  RedeemFullRightsTransferBidArgs: RedeemFullRightsTransferBidArgs,
  RedeemFullRightsTransferBid: RedeemFullRightsTransferBid
});

const initStore = ({ connection, wallet, isPublic = true, }) => __awaiter(void 0, void 0, void 0, function* () {
    const storeId = yield Store.getPDA(wallet.publicKey);
    const tx = new SetStore({ feePayer: wallet.publicKey }, {
        admin: new PublicKey(wallet.publicKey),
        store: storeId,
        isPublic,
    });
    const txId = yield sendTransaction({ connection, wallet, txs: [tx] });
    return { storeId, txId };
});

var index$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  auction: index$5,
  metadata: index$3,
  metaplex: index$2,
  vault: index$4,
  TokenAccount: TokenAccount,
  deserialize: deserialize,
  Transaction: Transaction,
  PayForFiles: PayForFiles,
  CreateMint: CreateMint,
  CreateTokenAccount: CreateTokenAccount,
  CreateAssociatedTokenAccount: CreateAssociatedTokenAccount,
  MintTo: MintTo
});

function prepareTokenAccountAndMintTx(connection, owner) {
    return __awaiter(this, void 0, void 0, function* () {
        const mint = Keypair.generate();
        const mintRent = yield connection.getMinimumBalanceForRentExemption(MintLayout.span);
        const createMintTx = new CreateMint({ feePayer: owner }, {
            newAccountPubkey: mint.publicKey,
            lamports: mintRent,
        });
        const recipient = yield Token.getAssociatedTokenAddress(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, mint.publicKey, owner);
        const createAssociatedTokenAccountTx = new CreateAssociatedTokenAccount({ feePayer: owner }, {
            associatedTokenAddress: recipient,
            splTokenMintAddress: mint.publicKey,
        });
        const mintToTx = new MintTo({ feePayer: owner }, {
            mint: mint.publicKey,
            dest: recipient,
            amount: 1,
        });
        return { mint, createMintTx, createAssociatedTokenAccountTx, mintToTx };
    });
}

const mintNFT = ({ connection, wallet, uri, maxSupply, }) => __awaiter(void 0, void 0, void 0, function* () {
    const { mint, createMintTx, createAssociatedTokenAccountTx, mintToTx } = yield prepareTokenAccountAndMintTx(connection, wallet.publicKey);
    const metadataPDA = yield Metadata.getPDA(mint.publicKey);
    const editionPDA = yield MasterEdition.getPDA(mint.publicKey);
    const { name, symbol, seller_fee_basis_points, properties: { creators }, } = yield lookup(uri);
    const creatorsData = creators.reduce((memo, { address, share }) => {
        const verified = address === wallet.publicKey.toString();
        const creator = new Creator({
            address,
            share,
            verified,
        });
        memo = [...memo, creator];
        return memo;
    }, []);
    const metadataData = new MetadataDataData({
        name,
        symbol,
        uri,
        sellerFeeBasisPoints: seller_fee_basis_points,
        creators: creatorsData,
    });
    const createMetadataTx = new CreateMetadata({
        feePayer: wallet.publicKey,
    }, {
        metadata: metadataPDA,
        metadataData,
        updateAuthority: wallet.publicKey,
        mint: mint.publicKey,
        mintAuthority: wallet.publicKey,
    });
    const masterEditionTx = new CreateMasterEdition({ feePayer: wallet.publicKey }, {
        edition: editionPDA,
        metadata: metadataPDA,
        updateAuthority: wallet.publicKey,
        mint: mint.publicKey,
        mintAuthority: wallet.publicKey,
        maxSupply: maxSupply ? new BN(maxSupply) : null,
    });
    const txId = yield sendTransaction({
        connection,
        signers: [mint],
        txs: [
            createMintTx,
            createMetadataTx,
            createAssociatedTokenAccountTx,
            mintToTx,
            masterEditionTx,
        ],
        wallet,
    });
    return {
        txId,
        mint: mint.publicKey,
        metadata: metadataPDA,
        edition: editionPDA,
    };
});

const mintEditionFromMaster = ({ connection, wallet, masterEditionMint, updateAuthority } = {}) => __awaiter(void 0, void 0, void 0, function* () {
    const masterPDA = yield MasterEdition.getPDA(masterEditionMint);
    const masterMetaPDA = yield Metadata.getPDA(masterEditionMint);
    const masterInfo = yield Account.getInfo(connection, masterPDA);
    const masterData = new MasterEdition(masterPDA, masterInfo).data;
    const editionValue = masterData.supply.add(new BN(1));
    const { mint, createMintTx, createAssociatedTokenAccountTx, mintToTx } = yield prepareTokenAccountAndMintTx(connection, wallet.publicKey);
    const tokenAccount = yield Token.getAssociatedTokenAddress(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, masterEditionMint, wallet.publicKey);
    const metadataPDA = yield Metadata.getPDA(mint.publicKey);
    const editionMarker = yield EditionMarker.getPDA(masterEditionMint, editionValue);
    const editionPDA = yield Edition.getPDA(mint.publicKey);
    const newEditionFromMasterTx = new MintNewEditionFromMasterEditionViaToken({ feePayer: wallet.publicKey }, {
        edition: editionPDA,
        metadata: metadataPDA,
        updateAuthority: updateAuthority !== null && updateAuthority !== void 0 ? updateAuthority : wallet.publicKey,
        mint: mint.publicKey,
        mintAuthority: wallet.publicKey,
        masterEdition: masterPDA,
        masterMetadata: masterMetaPDA,
        editionMarker,
        tokenOwner: wallet.publicKey,
        tokenAccount,
        editionValue,
    });
    const txId = yield sendTransaction({
        connection,
        signers: [mint],
        txs: [createMintTx, createAssociatedTokenAccountTx, mintToTx, newEditionFromMasterTx],
        wallet,
    });
    return {
        txId,
        mint: mint.publicKey,
        metadata: metadataPDA,
        edition: editionPDA,
    };
});

class TransactionsBatch {
    constructor({ beforeTransactions = [], transactions, afterTransactions = [], }) {
        this.signers = [];
        this.beforeTransactions = beforeTransactions;
        this.transactions = transactions;
        this.afterTransactions = afterTransactions;
    }
    addSigner(signer) {
        this.signers.push(signer);
    }
    addBeforeTransaction(transaction) {
        this.beforeTransactions.push(transaction);
    }
    addTransaction(transaction) {
        this.transactions.push(transaction);
    }
    addAfterTransaction(transaction) {
        this.afterTransactions.push(transaction);
    }
    toTransactions() {
        return [...this.beforeTransactions, ...this.transactions, ...this.afterTransactions];
    }
    toInstructions() {
        return this.toTransactions().flatMap((t) => t.instructions);
    }
}

const closeVault = ({ connection, wallet, vault, priceMint, }) => __awaiter(void 0, void 0, void 0, function* () {
    const accountRent = yield connection.getMinimumBalanceForRentExemption(AccountLayout.span);
    const fractionMintAuthority = yield Vault.getPDA(vault);
    const txBatch = new TransactionsBatch({ transactions: [] });
    const txOptions = { feePayer: wallet.publicKey };
    const { data: { fractionMint, fractionTreasury, redeemTreasury, pricingLookupAddress }, } = yield Vault.load(connection, vault);
    const fractionMintKey = new PublicKey(fractionMint);
    const fractionTreasuryKey = new PublicKey(fractionTreasury);
    const redeemTreasuryKey = new PublicKey(redeemTreasury);
    const pricingLookupAddressKey = new PublicKey(pricingLookupAddress);
    const activateVaultTx = new ActivateVault(txOptions, {
        vault,
        numberOfShares: new BN(0),
        fractionMint: fractionMintKey,
        fractionTreasury: fractionTreasuryKey,
        fractionMintAuthority,
        vaultAuthority: wallet.publicKey,
    });
    txBatch.addTransaction(activateVaultTx);
    const outstandingShareAccount = Keypair.generate();
    const outstandingShareAccountTx = new CreateTokenAccount(txOptions, {
        newAccountPubkey: outstandingShareAccount.publicKey,
        lamports: accountRent,
        mint: fractionMintKey,
        owner: wallet.publicKey,
    });
    txBatch.addTransaction(outstandingShareAccountTx);
    txBatch.addSigner(outstandingShareAccount);
    const payingTokenAccount = Keypair.generate();
    const payingTokenAccountTx = new CreateTokenAccount(txOptions, {
        newAccountPubkey: payingTokenAccount.publicKey,
        lamports: accountRent,
        mint: priceMint,
        owner: wallet.publicKey,
    });
    txBatch.addTransaction(payingTokenAccountTx);
    txBatch.addSigner(payingTokenAccount);
    const transferAuthority = Keypair.generate();
    const createApproveTx = (account) => new Transaction().add(Token.createApproveInstruction(TOKEN_PROGRAM_ID, account.publicKey, transferAuthority.publicKey, wallet.publicKey, [], 0));
    txBatch.addTransaction(createApproveTx(payingTokenAccount));
    txBatch.addTransaction(createApproveTx(outstandingShareAccount));
    txBatch.addSigner(transferAuthority);
    const combineVaultTx = new CombineVault(txOptions, {
        vault,
        outstandingShareTokenAccount: outstandingShareAccount.publicKey,
        payingTokenAccount: payingTokenAccount.publicKey,
        fractionMint: fractionMintKey,
        fractionTreasury: fractionTreasuryKey,
        redeemTreasury: redeemTreasuryKey,
        burnAuthority: fractionMintAuthority,
        externalPriceAccount: pricingLookupAddressKey,
        transferAuthority: transferAuthority.publicKey,
        vaultAuthority: wallet.publicKey,
        newVaultAuthority: wallet.publicKey,
    });
    txBatch.addTransaction(combineVaultTx);
    const txId = yield sendTransaction({
        connection,
        signers: txBatch.signers,
        txs: txBatch.transactions,
        wallet,
    });
    return {
        txId,
    };
});

const createVault = ({ connection, wallet, priceMint = NATIVE_MINT, externalPriceAccount, }) => __awaiter(void 0, void 0, void 0, function* () {
    const accountRent = yield connection.getMinimumBalanceForRentExemption(AccountLayout.span);
    const mintRent = yield connection.getMinimumBalanceForRentExemption(MintLayout.span);
    const vaultRent = yield connection.getMinimumBalanceForRentExemption(Vault.MAX_VAULT_SIZE);
    const vault = Keypair.generate();
    const vaultAuthority = yield Vault.getPDA(vault.publicKey);
    const txBatch = new TransactionsBatch({ transactions: [] });
    const fractionMint = Keypair.generate();
    const fractionMintTx = new CreateMint({ feePayer: wallet.publicKey }, {
        newAccountPubkey: fractionMint.publicKey,
        lamports: mintRent,
        owner: vaultAuthority,
        freezeAuthority: vaultAuthority,
    });
    txBatch.addTransaction(fractionMintTx);
    txBatch.addSigner(fractionMint);
    const redeemTreasury = Keypair.generate();
    const redeemTreasuryTx = new CreateTokenAccount({ feePayer: wallet.publicKey }, {
        newAccountPubkey: redeemTreasury.publicKey,
        lamports: accountRent,
        mint: priceMint,
        owner: vaultAuthority,
    });
    txBatch.addTransaction(redeemTreasuryTx);
    txBatch.addSigner(redeemTreasury);
    const fractionTreasury = Keypair.generate();
    const fractionTreasuryTx = new CreateTokenAccount({ feePayer: wallet.publicKey }, {
        newAccountPubkey: fractionTreasury.publicKey,
        lamports: accountRent,
        mint: fractionMint.publicKey,
        owner: vaultAuthority,
    });
    txBatch.addTransaction(fractionTreasuryTx);
    txBatch.addSigner(fractionTreasury);
    const uninitializedVaultTx = new Transaction().add(SystemProgram.createAccount({
        fromPubkey: wallet.publicKey,
        newAccountPubkey: vault.publicKey,
        lamports: vaultRent,
        space: Vault.MAX_VAULT_SIZE,
        programId: VaultProgram.PUBKEY,
    }));
    txBatch.addTransaction(uninitializedVaultTx);
    txBatch.addSigner(vault);
    const initVaultTx = new InitVault({ feePayer: wallet.publicKey }, {
        vault: vault.publicKey,
        vaultAuthority: wallet.publicKey,
        fractionalTreasury: fractionTreasury.publicKey,
        pricingLookupAddress: externalPriceAccount,
        redeemTreasury: redeemTreasury.publicKey,
        fractionalMint: fractionMint.publicKey,
        allowFurtherShareCreation: true,
    });
    txBatch.addTransaction(initVaultTx);
    const txId = yield sendTransaction({
        connection,
        signers: txBatch.signers,
        txs: txBatch.transactions,
        wallet,
    });
    return {
        txId,
        vault: vault.publicKey,
        fractionMint: fractionMint.publicKey,
        redeemTreasury: redeemTreasury.publicKey,
        fractionTreasury: fractionTreasury.publicKey,
    };
});

const createExternalPriceAccount = ({ connection, wallet, }) => __awaiter(void 0, void 0, void 0, function* () {
    const txBatch = new TransactionsBatch({ transactions: [] });
    const txOptions = { feePayer: wallet.publicKey };
    const epaRentExempt = yield connection.getMinimumBalanceForRentExemption(Vault.MAX_EXTERNAL_ACCOUNT_SIZE);
    const externalPriceAccount = Keypair.generate();
    const externalPriceAccountData = new ExternalPriceAccountData({
        pricePerShare: new BN(0),
        priceMint: NATIVE_MINT.toBase58(),
        allowedToCombine: true,
    });
    const uninitializedEPA = new Transaction().add(SystemProgram.createAccount({
        fromPubkey: wallet.publicKey,
        newAccountPubkey: externalPriceAccount.publicKey,
        lamports: epaRentExempt,
        space: Vault.MAX_EXTERNAL_ACCOUNT_SIZE,
        programId: VaultProgram.PUBKEY,
    }));
    txBatch.addTransaction(uninitializedEPA);
    txBatch.addSigner(externalPriceAccount);
    const updateEPA = new UpdateExternalPriceAccount(txOptions, {
        externalPriceAccount: externalPriceAccount.publicKey,
        externalPriceAccountData,
    });
    txBatch.addTransaction(updateEPA);
    const txId = yield sendTransaction({
        connection,
        signers: txBatch.signers,
        txs: txBatch.transactions,
        wallet,
    });
    return {
        txId,
        externalPriceAccount: externalPriceAccount.publicKey,
        priceMint: NATIVE_MINT,
    };
});

const createMetadata = ({ connection, wallet, editionMint, metadataData, updateAuthority } = {}) => __awaiter(void 0, void 0, void 0, function* () {
    const metadata = yield Metadata.getPDA(editionMint);
    const createMetadataTx = new CreateMetadata({ feePayer: wallet.publicKey }, {
        metadata,
        metadataData,
        updateAuthority: updateAuthority !== null && updateAuthority !== void 0 ? updateAuthority : wallet.publicKey,
        mint: editionMint,
        mintAuthority: wallet.publicKey,
    });
    return sendTransaction({
        connection,
        signers: [],
        txs: [createMetadataTx],
        wallet,
    });
});

const createMasterEdition = ({ connection, wallet, editionMint, updateAuthority, maxSupply } = {}) => __awaiter(void 0, void 0, void 0, function* () {
    const metadata = yield Metadata.getPDA(editionMint);
    const edition = yield MasterEdition.getPDA(editionMint);
    const createMetadataTx = new CreateMasterEdition({ feePayer: wallet.publicKey }, {
        edition,
        metadata,
        updateAuthority: updateAuthority !== null && updateAuthority !== void 0 ? updateAuthority : wallet.publicKey,
        mint: editionMint,
        mintAuthority: wallet.publicKey,
        maxSupply,
    });
    return sendTransaction({
        connection,
        signers: [],
        txs: [createMetadataTx],
        wallet,
    });
});

const signMetadata = ({ connection, wallet, editionMint, signer } = {}) => __awaiter(void 0, void 0, void 0, function* () {
    const metadata = yield Metadata.getPDA(editionMint);
    const signTx = new SignMetadata({ feePayer: wallet.publicKey }, {
        metadata,
        creator: signer ? signer.publicKey : wallet.publicKey,
    });
    return yield sendTransaction({
        connection,
        signers: signer ? [signer] : [],
        txs: [signTx],
        wallet,
    });
});

const updateMetadata = ({ connection, wallet, editionMint, newMetadataData, newUpdateAuthority, primarySaleHappened, } = {}) => __awaiter(void 0, void 0, void 0, function* () {
    const metadata = yield Metadata.getPDA(editionMint);
    const updateTx = new UpdateMetadata({ feePayer: wallet.publicKey }, {
        metadata,
        updateAuthority: wallet.publicKey,
        metadataData: newMetadataData,
        newUpdateAuthority,
        primarySaleHappened,
    });
    return sendTransaction({
        connection,
        signers: [],
        txs: [updateTx],
        wallet,
    });
});

const cancelBid = ({ connection, wallet, auction, bidderPotToken, destAccount, }) => __awaiter(void 0, void 0, void 0, function* () {
    const bidder = wallet.publicKey;
    const auctionManager = yield AuctionManager.getPDA(auction);
    const manager = yield AuctionManager.load(connection, auctionManager);
    const { data: { tokenMint }, } = yield manager.getAuction(connection);
    const auctionTokenMint = new PublicKey(tokenMint);
    const vault = new PublicKey(manager.data.vault);
    const auctionExtended = yield AuctionExtended.getPDA(vault);
    const bidderPot = yield BidderPot.getPDA(auction, bidder);
    const bidderMeta = yield BidderMetadata.getPDA(auction, bidder);
    const accountRentExempt = yield connection.getMinimumBalanceForRentExemption(AccountLayout.span);
    const txBatch = yield getCancelBidTransactions({
        destAccount,
        bidder,
        accountRentExempt,
        bidderPot,
        bidderPotToken,
        bidderMeta,
        auction,
        auctionExtended,
        auctionTokenMint,
        vault,
    });
    const txId = yield sendTransaction({
        connection,
        wallet,
        txs: txBatch.toTransactions(),
        signers: txBatch.signers,
    });
    return { txId };
});
const getCancelBidTransactions = ({ destAccount, bidder, accountRentExempt, bidderPot, bidderPotToken, bidderMeta, auction, auctionExtended, auctionTokenMint, vault, }) => __awaiter(void 0, void 0, void 0, function* () {
    const txBatch = new TransactionsBatch({ transactions: [] });
    if (!destAccount) {
        const account = Keypair.generate();
        const createTokenAccountTransaction = new CreateTokenAccount({ feePayer: bidder }, {
            newAccountPubkey: account.publicKey,
            lamports: accountRentExempt,
            mint: NATIVE_MINT,
        });
        const closeTokenAccountInstruction = new Transaction().add(Token.createCloseAccountInstruction(TOKEN_PROGRAM_ID, account.publicKey, bidder, bidder, []));
        txBatch.addTransaction(createTokenAccountTransaction);
        txBatch.addAfterTransaction(closeTokenAccountInstruction);
        txBatch.addSigner(account);
        destAccount = account.publicKey;
    }
    const cancelBidTransaction = new CancelBid({ feePayer: bidder }, {
        bidder,
        bidderToken: destAccount,
        bidderPot,
        bidderPotToken,
        bidderMeta,
        auction,
        auctionExtended,
        tokenMint: auctionTokenMint,
        resource: vault,
    });
    txBatch.addTransaction(cancelBidTransaction);
    return txBatch;
});

const placeBid = ({ connection, wallet, amount, auction, bidderPotToken, }) => __awaiter(void 0, void 0, void 0, function* () {
    const bidder = wallet.publicKey;
    const accountRentExempt = yield connection.getMinimumBalanceForRentExemption(AccountLayout.span);
    const auctionManager = yield AuctionManager.getPDA(auction);
    const manager = yield AuctionManager.load(connection, auctionManager);
    const { data: { tokenMint }, } = yield manager.getAuction(connection);
    const auctionTokenMint = new PublicKey(tokenMint);
    const vault = new PublicKey(manager.data.vault);
    const auctionExtended = yield AuctionExtended.getPDA(vault);
    const bidderPot = yield BidderPot.getPDA(auction, bidder);
    const bidderMeta = yield BidderMetadata.getPDA(auction, bidder);
    let txBatch = new TransactionsBatch({ transactions: [] });
    if (bidderPotToken) {
        txBatch = yield getCancelBidTransactions({
            destAccount: null,
            bidder,
            accountRentExempt,
            bidderPot,
            bidderPotToken,
            bidderMeta,
            auction,
            auctionExtended,
            auctionTokenMint,
            vault,
        });
    }
    else {
        const account = Keypair.generate();
        const createBidderPotTransaction = new CreateTokenAccount({ feePayer: bidder }, {
            newAccountPubkey: account.publicKey,
            lamports: accountRentExempt,
            mint: auctionTokenMint,
            owner: auction,
        });
        txBatch.addSigner(account);
        txBatch.addTransaction(createBidderPotTransaction);
        bidderPotToken = account.publicKey;
    }
    const payingAccount = Keypair.generate();
    const createTokenAccountTransaction = new CreateTokenAccount({ feePayer: bidder }, {
        newAccountPubkey: payingAccount.publicKey,
        lamports: amount.toNumber() + accountRentExempt * 3,
        mint: NATIVE_MINT,
    });
    const closeTokenAccountTransaction = new Transaction().add(Token.createCloseAccountInstruction(TOKEN_PROGRAM_ID, payingAccount.publicKey, bidder, bidder, []));
    txBatch.addTransaction(createTokenAccountTransaction);
    txBatch.addAfterTransaction(closeTokenAccountTransaction);
    txBatch.addSigner(payingAccount);
    const transferAuthority = Keypair.generate();
    const createApproveTransaction = new Transaction().add(Token.createApproveInstruction(TOKEN_PROGRAM_ID, payingAccount.publicKey, transferAuthority.publicKey, bidder, [], amount.toNumber()));
    txBatch.addTransaction(createApproveTransaction);
    const createRevokeTransaction = new Transaction().add(Token.createRevokeInstruction(TOKEN_PROGRAM_ID, payingAccount.publicKey, bidder, []));
    txBatch.addAfterTransaction(createRevokeTransaction);
    txBatch.addSigner(transferAuthority);
    const placeBidTransaction = new PlaceBid({ feePayer: bidder }, {
        bidder,
        bidderToken: payingAccount.publicKey,
        bidderPot,
        bidderPotToken,
        bidderMeta,
        auction,
        auctionExtended,
        tokenMint: auctionTokenMint,
        transferAuthority: transferAuthority.publicKey,
        amount,
        resource: vault,
    });
    txBatch.addTransaction(placeBidTransaction);
    const txId = yield sendTransaction({
        connection,
        wallet,
        txs: txBatch.toTransactions(),
        signers: txBatch.signers,
    });
    return { txId, bidderPotToken, bidderMeta };
});

const redeemBid = ({ connection, wallet, store, auction, }) => __awaiter(void 0, void 0, void 0, function* () {
    const bidder = wallet.publicKey;
    const accountRentExempt = yield connection.getMinimumBalanceForRentExemption(AccountLayout.span);
    const auctionManager = yield AuctionManager.getPDA(auction);
    const manager = yield AuctionManager.load(connection, auctionManager);
    const vault = yield Vault.load(connection, manager.data.vault);
    const fractionMint = new PublicKey(vault.data.fractionMint);
    const auctionExtended = yield AuctionExtended.getPDA(vault.pubkey);
    const [safetyDepositBox] = yield vault.getSafetyDepositBoxes(connection);
    const tokenMint = new PublicKey(safetyDepositBox.data.tokenMint);
    const safetyDepositTokenStore = new PublicKey(safetyDepositBox.data.store);
    const bidderMeta = yield BidderMetadata.getPDA(auction, bidder);
    const bidRedemption = yield getBidRedemptionPDA(auction, bidderMeta);
    const safetyDepositConfig = yield SafetyDepositConfig.getPDA(auctionManager, safetyDepositBox.pubkey);
    const transferAuthority = yield Vault.getPDA(vault.pubkey);
    const metadata = yield Metadata.getPDA(tokenMint);
    const txBatch = yield getRedeemBidTransactions({
        accountRentExempt,
        tokenMint,
        bidder,
        bidderMeta,
        store,
        vault: vault.pubkey,
        auction,
        auctionExtended,
        auctionManager,
        fractionMint,
        safetyDepositTokenStore,
        safetyDeposit: safetyDepositBox.pubkey,
        bidRedemption,
        safetyDepositConfig,
        transferAuthority,
        metadata,
    });
    const txId = yield sendTransaction({
        connection,
        wallet,
        txs: txBatch.toTransactions(),
        signers: txBatch.signers,
    });
    return { txId };
});
const getRedeemBidTransactions = ({ accountRentExempt, bidder, tokenMint, store, vault, auction, auctionManager, auctionExtended, bidRedemption, bidderMeta: bidMetadata, safetyDepositTokenStore, safetyDeposit, fractionMint, safetyDepositConfig, transferAuthority, metadata, }) => __awaiter(void 0, void 0, void 0, function* () {
    const txBatch = new TransactionsBatch({ transactions: [] });
    const account = Keypair.generate();
    const createDestinationTransaction = new CreateTokenAccount({ feePayer: bidder }, {
        newAccountPubkey: account.publicKey,
        lamports: accountRentExempt,
        mint: tokenMint,
    });
    txBatch.addSigner(account);
    txBatch.addTransaction(createDestinationTransaction);
    const redeemBidTransaction = new RedeemFullRightsTransferBid({ feePayer: bidder }, {
        store,
        vault,
        auction,
        auctionManager,
        bidRedemption,
        bidMetadata,
        safetyDepositTokenStore,
        destination: account.publicKey,
        safetyDeposit,
        fractionMint,
        bidder,
        safetyDepositConfig,
        auctionExtended,
        transferAuthority,
        newAuthority: bidder,
        masterMetadata: metadata,
    });
    txBatch.addTransaction(redeemBidTransaction);
    const updatePrimarySaleHappenedViaTokenTransaction = new UpdatePrimarySaleHappenedViaToken({ feePayer: bidder }, {
        metadata,
        owner: bidder,
        tokenAccount: account.publicKey,
    });
    txBatch.addTransaction(updatePrimarySaleHappenedViaTokenTransaction);
    return txBatch;
});
const getBidRedemptionPDA = (auction, bidderMeta) => __awaiter(void 0, void 0, void 0, function* () {
    return (yield PublicKey.findProgramAddress([Buffer.from(MetaplexProgram.PREFIX), auction.toBuffer(), bidderMeta.toBuffer()], MetaplexProgram.PUBKEY))[0];
});

const claimBid = ({ connection, wallet, store, auction, bidderPotToken, }) => __awaiter(void 0, void 0, void 0, function* () {
    const bidder = wallet.publicKey;
    const auctionManager = yield AuctionManager.getPDA(auction);
    const manager = yield AuctionManager.load(connection, auctionManager);
    const vault = new PublicKey(manager.data.vault);
    const { data: { tokenMint }, } = yield Auction.load(connection, auction);
    const acceptPayment = new PublicKey(manager.data.acceptPayment);
    const auctionExtended = yield AuctionExtended.getPDA(vault);
    const auctionTokenMint = new PublicKey(tokenMint);
    const bidderPot = yield BidderPot.getPDA(auction, bidder);
    const txBatch = yield getClaimBidTransactions({
        auctionTokenMint,
        bidder,
        store,
        vault,
        auction,
        auctionExtended,
        auctionManager,
        acceptPayment,
        bidderPot,
        bidderPotToken,
    });
    const txId = yield sendTransaction({
        connection,
        wallet,
        txs: txBatch.toTransactions(),
        signers: txBatch.signers,
    });
    return { txId };
});
const getClaimBidTransactions = ({ bidder, auctionTokenMint, store, vault, auction, auctionManager, auctionExtended, acceptPayment, bidderPot, bidderPotToken, }) => __awaiter(void 0, void 0, void 0, function* () {
    const txBatch = new TransactionsBatch({ transactions: [] });
    const claimBidTransaction = new ClaimBid({ feePayer: bidder }, {
        store,
        vault,
        auction,
        auctionExtended,
        auctionManager,
        bidder,
        tokenMint: auctionTokenMint,
        acceptPayment,
        bidderPot,
        bidderPotToken,
    });
    txBatch.addTransaction(claimBidTransaction);
    return txBatch;
});

var retry$2 = {};

function RetryOperation(timeouts, options) {
  // Compatibility for the old (timeouts, retryForever) signature
  if (typeof options === 'boolean') {
    options = { forever: options };
  }

  this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
  this._timeouts = timeouts;
  this._options = options || {};
  this._maxRetryTime = options && options.maxRetryTime || Infinity;
  this._fn = null;
  this._errors = [];
  this._attempts = 1;
  this._operationTimeout = null;
  this._operationTimeoutCb = null;
  this._timeout = null;
  this._operationStart = null;
  this._timer = null;

  if (this._options.forever) {
    this._cachedTimeouts = this._timeouts.slice(0);
  }
}
var retry_operation = RetryOperation;

RetryOperation.prototype.reset = function() {
  this._attempts = 1;
  this._timeouts = this._originalTimeouts.slice(0);
};

RetryOperation.prototype.stop = function() {
  if (this._timeout) {
    clearTimeout(this._timeout);
  }
  if (this._timer) {
    clearTimeout(this._timer);
  }

  this._timeouts       = [];
  this._cachedTimeouts = null;
};

RetryOperation.prototype.retry = function(err) {
  if (this._timeout) {
    clearTimeout(this._timeout);
  }

  if (!err) {
    return false;
  }
  var currentTime = new Date().getTime();
  if (err && currentTime - this._operationStart >= this._maxRetryTime) {
    this._errors.push(err);
    this._errors.unshift(new Error('RetryOperation timeout occurred'));
    return false;
  }

  this._errors.push(err);

  var timeout = this._timeouts.shift();
  if (timeout === undefined) {
    if (this._cachedTimeouts) {
      // retry forever, only keep last error
      this._errors.splice(0, this._errors.length - 1);
      timeout = this._cachedTimeouts.slice(-1);
    } else {
      return false;
    }
  }

  var self = this;
  this._timer = setTimeout(function() {
    self._attempts++;

    if (self._operationTimeoutCb) {
      self._timeout = setTimeout(function() {
        self._operationTimeoutCb(self._attempts);
      }, self._operationTimeout);

      if (self._options.unref) {
          self._timeout.unref();
      }
    }

    self._fn(self._attempts);
  }, timeout);

  if (this._options.unref) {
      this._timer.unref();
  }

  return true;
};

RetryOperation.prototype.attempt = function(fn, timeoutOps) {
  this._fn = fn;

  if (timeoutOps) {
    if (timeoutOps.timeout) {
      this._operationTimeout = timeoutOps.timeout;
    }
    if (timeoutOps.cb) {
      this._operationTimeoutCb = timeoutOps.cb;
    }
  }

  var self = this;
  if (this._operationTimeoutCb) {
    this._timeout = setTimeout(function() {
      self._operationTimeoutCb();
    }, self._operationTimeout);
  }

  this._operationStart = new Date().getTime();

  this._fn(this._attempts);
};

RetryOperation.prototype.try = function(fn) {
  console.log('Using RetryOperation.try() is deprecated');
  this.attempt(fn);
};

RetryOperation.prototype.start = function(fn) {
  console.log('Using RetryOperation.start() is deprecated');
  this.attempt(fn);
};

RetryOperation.prototype.start = RetryOperation.prototype.try;

RetryOperation.prototype.errors = function() {
  return this._errors;
};

RetryOperation.prototype.attempts = function() {
  return this._attempts;
};

RetryOperation.prototype.mainError = function() {
  if (this._errors.length === 0) {
    return null;
  }

  var counts = {};
  var mainError = null;
  var mainErrorCount = 0;

  for (var i = 0; i < this._errors.length; i++) {
    var error = this._errors[i];
    var message = error.message;
    var count = (counts[message] || 0) + 1;

    counts[message] = count;

    if (count >= mainErrorCount) {
      mainError = error;
      mainErrorCount = count;
    }
  }

  return mainError;
};

(function (exports) {
var RetryOperation = retry_operation;

exports.operation = function(options) {
  var timeouts = exports.timeouts(options);
  return new RetryOperation(timeouts, {
      forever: options && (options.forever || options.retries === Infinity),
      unref: options && options.unref,
      maxRetryTime: options && options.maxRetryTime
  });
};

exports.timeouts = function(options) {
  if (options instanceof Array) {
    return [].concat(options);
  }

  var opts = {
    retries: 10,
    factor: 2,
    minTimeout: 1 * 1000,
    maxTimeout: Infinity,
    randomize: false
  };
  for (var key in options) {
    opts[key] = options[key];
  }

  if (opts.minTimeout > opts.maxTimeout) {
    throw new Error('minTimeout is greater than maxTimeout');
  }

  var timeouts = [];
  for (var i = 0; i < opts.retries; i++) {
    timeouts.push(this.createTimeout(i, opts));
  }

  if (options && options.forever && !timeouts.length) {
    timeouts.push(this.createTimeout(i, opts));
  }

  // sort the array numerically ascending
  timeouts.sort(function(a,b) {
    return a - b;
  });

  return timeouts;
};

exports.createTimeout = function(attempt, opts) {
  var random = (opts.randomize)
    ? (Math.random() + 1)
    : 1;

  var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
  timeout = Math.min(timeout, opts.maxTimeout);

  return timeout;
};

exports.wrap = function(obj, options, methods) {
  if (options instanceof Array) {
    methods = options;
    options = null;
  }

  if (!methods) {
    methods = [];
    for (var key in obj) {
      if (typeof obj[key] === 'function') {
        methods.push(key);
      }
    }
  }

  for (var i = 0; i < methods.length; i++) {
    var method   = methods[i];
    var original = obj[method];

    obj[method] = function retryWrapper(original) {
      var op       = exports.operation(options);
      var args     = Array.prototype.slice.call(arguments, 1);
      var callback = args.pop();

      args.push(function(err) {
        if (op.retry(err)) {
          return;
        }
        if (err) {
          arguments[0] = op.mainError();
        }
        callback.apply(this, arguments);
      });

      op.attempt(function() {
        original.apply(obj, args);
      });
    }.bind(obj, original);
    obj[method].options = options;
  }
};
}(retry$2));

var retry$1 = retry$2;

// Packages
var retrier = retry$1;

function retry(fn, opts) {
  function run(resolve, reject) {
    var options = opts || {};
    var op;

    // Default `randomize` to true
    if (!('randomize' in options)) {
      options.randomize = true;
    }

    op = retrier.operation(options);

    // We allow the user to abort retrying
    // this makes sense in the cases where
    // knowledge is obtained that retrying
    // would be futile (e.g.: auth errors)

    function bail(err) {
      reject(err || new Error('Aborted'));
    }

    function onError(err, num) {
      if (err.bail) {
        bail(err);
        return;
      }

      if (!op.retry(err)) {
        reject(op.mainError());
      } else if (options.onRetry) {
        options.onRetry(err, num);
      }
    }

    function runAttempt(num) {
      var val;

      try {
        val = fn(bail, num);
      } catch (err) {
        onError(err, num);
        return;
      }

      Promise.resolve(val)
        .then(resolve)
        .catch(function catchIt(err) {
          onError(err, num);
        });
    }

    op.attempt(runAttempt);
  }

  return new Promise(run);
}

var lib = retry;

const instantSale = ({ connection, wallet, store, auction, }) => __awaiter(void 0, void 0, void 0, function* () {
    const bidder = wallet.publicKey;
    const accountRentExempt = yield connection.getMinimumBalanceForRentExemption(AccountLayout.span);
    const auctionManager = yield AuctionManager.getPDA(auction);
    const manager = yield AuctionManager.load(connection, auctionManager);
    const vault = yield Vault.load(connection, manager.data.vault);
    const { data: { tokenMint }, } = yield Auction.load(connection, auction);
    const auctionExtended = yield AuctionExtended.getPDA(vault.pubkey);
    const acceptPayment = new PublicKey(manager.data.acceptPayment);
    const { data: { instantSalePrice }, } = yield AuctionExtended.load(connection, auctionExtended);
    const auctionTokenMint = new PublicKey(tokenMint);
    const bidderPot = yield BidderPot.getPDA(auction, bidder);
    const fractionMint = new PublicKey(vault.data.fractionMint);
    const [safetyDepositBox] = yield vault.getSafetyDepositBoxes(connection);
    const metadataTokenMint = new PublicKey(safetyDepositBox.data.tokenMint);
    const safetyDepositTokenStore = new PublicKey(safetyDepositBox.data.store);
    const safetyDepositConfig = yield SafetyDepositConfig.getPDA(auctionManager, safetyDepositBox.pubkey);
    const transferAuthority = yield Vault.getPDA(vault.pubkey);
    const metadata = yield Metadata.getPDA(metadataTokenMint);
    const { bidderPotToken, bidderMeta } = yield placeBid({
        connection,
        wallet,
        amount: instantSalePrice,
        auction,
    });
    yield lib((bail) => __awaiter(void 0, void 0, void 0, function* () {
        yield Account.getInfo(connection, bidderMeta);
    }));
    const bidRedemption = yield getBidRedemptionPDA(auction, bidderMeta);
    const redeemBatch = yield getRedeemBidTransactions({
        accountRentExempt,
        tokenMint: metadataTokenMint,
        bidder,
        bidderMeta,
        store,
        vault: vault.pubkey,
        auction,
        auctionExtended,
        auctionManager,
        fractionMint,
        safetyDepositTokenStore,
        safetyDeposit: safetyDepositBox.pubkey,
        bidRedemption,
        safetyDepositConfig,
        transferAuthority,
        metadata,
    });
    const claimBatch = yield getClaimBidTransactions({
        auctionTokenMint,
        bidder,
        store,
        vault: vault.pubkey,
        auction,
        auctionExtended,
        auctionManager,
        acceptPayment,
        bidderPot,
        bidderPotToken,
    });
    const txs = [...redeemBatch.toTransactions(), ...claimBatch.toTransactions()];
    const signers = [...redeemBatch.signers, ...claimBatch.signers];
    const txId = yield sendTransaction({
        connection,
        wallet,
        txs,
        signers,
    });
    return { txId };
});

const burnToken = ({ connection, wallet, token, mint, amount, owner, close = true, }) => __awaiter(void 0, void 0, void 0, function* () {
    const tx = new Transaction({ feePayer: wallet.publicKey }).add(Token.createBurnInstruction(TOKEN_PROGRAM_ID, mint, token, owner !== null && owner !== void 0 ? owner : wallet.publicKey, [], amount));
    if (close) {
        tx.add(Token.createCloseAccountInstruction(TOKEN_PROGRAM_ID, token, wallet.publicKey, owner !== null && owner !== void 0 ? owner : wallet.publicKey, []));
    }
    const txId = yield sendTransaction({ connection, wallet, txs: [tx] });
    return { txId };
});

const sendToken = ({ connection, wallet, source, destination, mint, amount, }) => __awaiter(void 0, void 0, void 0, function* () {
    const txs = [];
    const destAta = yield Token.getAssociatedTokenAddress(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, mint, destination);
    const transactionCtorFields = {
        feePayer: wallet.publicKey,
    };
    try {
        yield Account.load(connection, destAta);
    }
    catch (_a) {
        txs.push(new CreateAssociatedTokenAccount(transactionCtorFields, {
            associatedTokenAddress: destAta,
            splTokenMintAddress: mint,
            walletAddress: destination,
        }));
    }
    txs.push(new Transaction(transactionCtorFields).add(Token.createTransferInstruction(TOKEN_PROGRAM_ID, source, destAta, wallet.publicKey, [], amount)));
    const txId = yield sendTransaction({ connection, wallet, txs });
    return { txId };
});

var index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  sendTransaction: sendTransaction,
  initStore: initStore,
  mintNFT: mintNFT,
  mintEditionFromMaster: mintEditionFromMaster,
  closeVault: closeVault,
  createVault: createVault,
  createExternalPriceAccount: createExternalPriceAccount,
  createMetadata: createMetadata,
  createMasterEdition: createMasterEdition,
  signMetadata: signMetadata,
  updateMetadata: updateMetadata,
  cancelBid: cancelBid,
  getCancelBidTransactions: getCancelBidTransactions,
  placeBid: placeBid,
  redeemBid: redeemBid,
  getRedeemBidTransactions: getRedeemBidTransactions,
  getBidRedemptionPDA: getBidRedemptionPDA,
  claimBid: claimBid,
  getClaimBidTransactions: getClaimBidTransactions,
  instantSale: instantSale,
  burnToken: burnToken,
  sendToken: sendToken,
  prepareTokenAccountAndMintTx: prepareTokenAccountAndMintTx
});

export { Account, ArweaveStorage, ChainId, Coingecko, Connection, Currency, ENV, NodeWallet, index as actions, errors, index$1 as programs, index$6 as utils };
//# sourceMappingURL=index.browser.esm.js.map
